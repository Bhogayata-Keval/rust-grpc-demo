// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `metrics_service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest)
pub struct ExportMetricsServiceRequest {
    // message fields
    ///  An array of ResourceMetrics.
    ///  For data coming from a single resource this array will typically contain one
    ///  element. Intermediary nodes (such as OpenTelemetry Collector) that receive
    ///  data from multiple origins typically batch the data before forwarding further and
    ///  in that case this array will contain multiple elements.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.resource_metrics)
    pub resource_metrics: ::std::vec::Vec<ResourceMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExportMetricsServiceRequest {
    fn default() -> &'a ExportMetricsServiceRequest {
        <ExportMetricsServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExportMetricsServiceRequest {
    pub fn new() -> ExportMetricsServiceRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resource_metrics",
            |m: &ExportMetricsServiceRequest| { &m.resource_metrics },
            |m: &mut ExportMetricsServiceRequest| { &mut m.resource_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExportMetricsServiceRequest>(
            "ExportMetricsServiceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExportMetricsServiceRequest {
    const NAME: &'static str = "ExportMetricsServiceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.resource_metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.resource_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.resource_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExportMetricsServiceRequest {
        ExportMetricsServiceRequest::new()
    }

    fn clear(&mut self) {
        self.resource_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExportMetricsServiceRequest {
        static instance: ExportMetricsServiceRequest = ExportMetricsServiceRequest {
            resource_metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExportMetricsServiceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExportMetricsServiceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExportMetricsServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExportMetricsServiceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse)
pub struct ExportMetricsServiceResponse {
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExportMetricsServiceResponse {
    fn default() -> &'a ExportMetricsServiceResponse {
        <ExportMetricsServiceResponse as ::protobuf::Message>::default_instance()
    }
}

impl ExportMetricsServiceResponse {
    pub fn new() -> ExportMetricsServiceResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExportMetricsServiceResponse>(
            "ExportMetricsServiceResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExportMetricsServiceResponse {
    const NAME: &'static str = "ExportMetricsServiceResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExportMetricsServiceResponse {
        ExportMetricsServiceResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExportMetricsServiceResponse {
        static instance: ExportMetricsServiceResponse = ExportMetricsServiceResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExportMetricsServiceResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExportMetricsServiceResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExportMetricsServiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExportMetricsServiceResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  MetricsData represents the metrics data that can be stored in a persistent
///  storage, OR can be embedded by other protocols that transfer OTLP metrics
///  data but do not implement the OTLP protocol.
///
///  The main difference between this message and collector protocol is that
///  in this message there will not be any "control" or "metadata" specific to
///  OTLP protocol.
///
///  When new fields are added into this message, the OTLP request MUST be updated
///  as well.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.MetricsData)
pub struct MetricsData {
    // message fields
    ///  An array of ResourceMetrics.
    ///  For data coming from a single resource this array will typically contain
    ///  one element. Intermediary nodes that receive data from multiple origins
    ///  typically batch the data before forwarding further and in that case this
    ///  array will contain multiple elements.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.MetricsData.resource_metrics)
    pub resource_metrics: ::std::vec::Vec<ResourceMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.MetricsData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MetricsData {
    fn default() -> &'a MetricsData {
        <MetricsData as ::protobuf::Message>::default_instance()
    }
}

impl MetricsData {
    pub fn new() -> MetricsData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resource_metrics",
            |m: &MetricsData| { &m.resource_metrics },
            |m: &mut MetricsData| { &mut m.resource_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MetricsData>(
            "MetricsData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MetricsData {
    const NAME: &'static str = "MetricsData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.resource_metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.resource_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.resource_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MetricsData {
        MetricsData::new()
    }

    fn clear(&mut self) {
        self.resource_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MetricsData {
        static instance: MetricsData = MetricsData {
            resource_metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MetricsData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MetricsData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MetricsData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetricsData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A collection of ScopeMetrics from a Resource.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.ResourceMetrics)
pub struct ResourceMetrics {
    // message fields
    ///  The resource for the metrics in this message.
    ///  If this field is not set then no resource info is known.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ResourceMetrics.resource)
    pub resource: ::protobuf::MessageField<Resource>,
    ///  A list of metrics that originate from a resource.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ResourceMetrics.scope_metrics)
    pub scope_metrics: ::std::vec::Vec<ScopeMetrics>,
    ///  This schema_url applies to the data in the "resource" field. It does not apply
    ///  to the data in the "scope_metrics" field which have their own schema_url field.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ResourceMetrics.schema_url)
    pub schema_url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.ResourceMetrics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResourceMetrics {
    fn default() -> &'a ResourceMetrics {
        <ResourceMetrics as ::protobuf::Message>::default_instance()
    }
}

impl ResourceMetrics {
    pub fn new() -> ResourceMetrics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Resource>(
            "resource",
            |m: &ResourceMetrics| { &m.resource },
            |m: &mut ResourceMetrics| { &mut m.resource },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scope_metrics",
            |m: &ResourceMetrics| { &m.scope_metrics },
            |m: &mut ResourceMetrics| { &mut m.scope_metrics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "schema_url",
            |m: &ResourceMetrics| { &m.schema_url },
            |m: &mut ResourceMetrics| { &mut m.schema_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceMetrics>(
            "ResourceMetrics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResourceMetrics {
    const NAME: &'static str = "ResourceMetrics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resource)?;
                },
                18 => {
                    self.scope_metrics.push(is.read_message()?);
                },
                26 => {
                    self.schema_url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.resource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.scope_metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.schema_url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.schema_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.resource.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.scope_metrics {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.schema_url.is_empty() {
            os.write_string(3, &self.schema_url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResourceMetrics {
        ResourceMetrics::new()
    }

    fn clear(&mut self) {
        self.resource.clear();
        self.scope_metrics.clear();
        self.schema_url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResourceMetrics {
        static instance: ResourceMetrics = ResourceMetrics {
            resource: ::protobuf::MessageField::none(),
            scope_metrics: ::std::vec::Vec::new(),
            schema_url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResourceMetrics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResourceMetrics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResourceMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceMetrics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A collection of Metrics produced by an Scope.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.ScopeMetrics)
pub struct ScopeMetrics {
    // message fields
    ///  The instrumentation scope information for the metrics in this message.
    ///  Semantically when InstrumentationScope isn't set, it is equivalent with
    ///  an empty instrumentation scope name (unknown).
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ScopeMetrics.scope)
    pub scope: ::protobuf::MessageField<InstrumentationScope>,
    ///  A list of metrics that originate from an instrumentation library.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ScopeMetrics.metrics)
    pub metrics: ::std::vec::Vec<Metric>,
    ///  This schema_url applies to all metrics in the "metrics" field.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ScopeMetrics.schema_url)
    pub schema_url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.ScopeMetrics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScopeMetrics {
    fn default() -> &'a ScopeMetrics {
        <ScopeMetrics as ::protobuf::Message>::default_instance()
    }
}

impl ScopeMetrics {
    pub fn new() -> ScopeMetrics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, InstrumentationScope>(
            "scope",
            |m: &ScopeMetrics| { &m.scope },
            |m: &mut ScopeMetrics| { &mut m.scope },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "metrics",
            |m: &ScopeMetrics| { &m.metrics },
            |m: &mut ScopeMetrics| { &mut m.metrics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "schema_url",
            |m: &ScopeMetrics| { &m.schema_url },
            |m: &mut ScopeMetrics| { &mut m.schema_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScopeMetrics>(
            "ScopeMetrics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScopeMetrics {
    const NAME: &'static str = "ScopeMetrics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scope)?;
                },
                18 => {
                    self.metrics.push(is.read_message()?);
                },
                26 => {
                    self.schema_url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.scope.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.schema_url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.schema_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.scope.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.metrics {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.schema_url.is_empty() {
            os.write_string(3, &self.schema_url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScopeMetrics {
        ScopeMetrics::new()
    }

    fn clear(&mut self) {
        self.scope.clear();
        self.metrics.clear();
        self.schema_url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScopeMetrics {
        static instance: ScopeMetrics = ScopeMetrics {
            scope: ::protobuf::MessageField::none(),
            metrics: ::std::vec::Vec::new(),
            schema_url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScopeMetrics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScopeMetrics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScopeMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScopeMetrics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.Metric)
pub struct Metric {
    // message fields
    ///  name of the metric, including its DNS name prefix. It must be unique.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.Metric.name)
    pub name: ::std::string::String,
    ///  description of the metric, which can be used in documentation.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.Metric.description)
    pub description: ::std::string::String,
    ///  unit in which the metric value is reported. Follows the format
    ///  described by http://unitsofmeasure.org/ucum.html.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.Metric.unit)
    pub unit: ::std::string::String,
    // message oneof groups
    pub data: ::std::option::Option<metric::Data>,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.Metric.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Metric {
    fn default() -> &'a Metric {
        <Metric as ::protobuf::Message>::default_instance()
    }
}

impl Metric {
    pub fn new() -> Metric {
        ::std::default::Default::default()
    }

    // .opentelemetry.proto.collector.metrics.v1.Gauge gauge = 5;

    pub fn gauge(&self) -> &Gauge {
        match self.data {
            ::std::option::Option::Some(metric::Data::Gauge(ref v)) => v,
            _ => <Gauge as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_gauge(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_gauge(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(metric::Data::Gauge(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gauge(&mut self, v: Gauge) {
        self.data = ::std::option::Option::Some(metric::Data::Gauge(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gauge(&mut self) -> &mut Gauge {
        if let ::std::option::Option::Some(metric::Data::Gauge(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(metric::Data::Gauge(Gauge::new()));
        }
        match self.data {
            ::std::option::Option::Some(metric::Data::Gauge(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gauge(&mut self) -> Gauge {
        if self.has_gauge() {
            match self.data.take() {
                ::std::option::Option::Some(metric::Data::Gauge(v)) => v,
                _ => panic!(),
            }
        } else {
            Gauge::new()
        }
    }

    // .opentelemetry.proto.collector.metrics.v1.Sum sum = 7;

    pub fn sum(&self) -> &Sum {
        match self.data {
            ::std::option::Option::Some(metric::Data::Sum(ref v)) => v,
            _ => <Sum as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sum(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_sum(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(metric::Data::Sum(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: Sum) {
        self.data = ::std::option::Option::Some(metric::Data::Sum(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sum(&mut self) -> &mut Sum {
        if let ::std::option::Option::Some(metric::Data::Sum(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(metric::Data::Sum(Sum::new()));
        }
        match self.data {
            ::std::option::Option::Some(metric::Data::Sum(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sum(&mut self) -> Sum {
        if self.has_sum() {
            match self.data.take() {
                ::std::option::Option::Some(metric::Data::Sum(v)) => v,
                _ => panic!(),
            }
        } else {
            Sum::new()
        }
    }

    // .opentelemetry.proto.collector.metrics.v1.Histogram histogram = 9;

    pub fn histogram(&self) -> &Histogram {
        match self.data {
            ::std::option::Option::Some(metric::Data::Histogram(ref v)) => v,
            _ => <Histogram as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_histogram(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_histogram(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(metric::Data::Histogram(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_histogram(&mut self, v: Histogram) {
        self.data = ::std::option::Option::Some(metric::Data::Histogram(v))
    }

    // Mutable pointer to the field.
    pub fn mut_histogram(&mut self) -> &mut Histogram {
        if let ::std::option::Option::Some(metric::Data::Histogram(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(metric::Data::Histogram(Histogram::new()));
        }
        match self.data {
            ::std::option::Option::Some(metric::Data::Histogram(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_histogram(&mut self) -> Histogram {
        if self.has_histogram() {
            match self.data.take() {
                ::std::option::Option::Some(metric::Data::Histogram(v)) => v,
                _ => panic!(),
            }
        } else {
            Histogram::new()
        }
    }

    // .opentelemetry.proto.collector.metrics.v1.ExponentialHistogram exponential_histogram = 10;

    pub fn exponential_histogram(&self) -> &ExponentialHistogram {
        match self.data {
            ::std::option::Option::Some(metric::Data::ExponentialHistogram(ref v)) => v,
            _ => <ExponentialHistogram as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_exponential_histogram(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_exponential_histogram(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(metric::Data::ExponentialHistogram(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exponential_histogram(&mut self, v: ExponentialHistogram) {
        self.data = ::std::option::Option::Some(metric::Data::ExponentialHistogram(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exponential_histogram(&mut self) -> &mut ExponentialHistogram {
        if let ::std::option::Option::Some(metric::Data::ExponentialHistogram(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(metric::Data::ExponentialHistogram(ExponentialHistogram::new()));
        }
        match self.data {
            ::std::option::Option::Some(metric::Data::ExponentialHistogram(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exponential_histogram(&mut self) -> ExponentialHistogram {
        if self.has_exponential_histogram() {
            match self.data.take() {
                ::std::option::Option::Some(metric::Data::ExponentialHistogram(v)) => v,
                _ => panic!(),
            }
        } else {
            ExponentialHistogram::new()
        }
    }

    // .opentelemetry.proto.collector.metrics.v1.Summary summary = 11;

    pub fn summary(&self) -> &Summary {
        match self.data {
            ::std::option::Option::Some(metric::Data::Summary(ref v)) => v,
            _ => <Summary as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_summary(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_summary(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(metric::Data::Summary(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: Summary) {
        self.data = ::std::option::Option::Some(metric::Data::Summary(v))
    }

    // Mutable pointer to the field.
    pub fn mut_summary(&mut self) -> &mut Summary {
        if let ::std::option::Option::Some(metric::Data::Summary(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(metric::Data::Summary(Summary::new()));
        }
        match self.data {
            ::std::option::Option::Some(metric::Data::Summary(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_summary(&mut self) -> Summary {
        if self.has_summary() {
            match self.data.take() {
                ::std::option::Option::Some(metric::Data::Summary(v)) => v,
                _ => panic!(),
            }
        } else {
            Summary::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Metric| { &m.name },
            |m: &mut Metric| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &Metric| { &m.description },
            |m: &mut Metric| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unit",
            |m: &Metric| { &m.unit },
            |m: &mut Metric| { &mut m.unit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Gauge>(
            "gauge",
            Metric::has_gauge,
            Metric::gauge,
            Metric::mut_gauge,
            Metric::set_gauge,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Sum>(
            "sum",
            Metric::has_sum,
            Metric::sum,
            Metric::mut_sum,
            Metric::set_sum,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Histogram>(
            "histogram",
            Metric::has_histogram,
            Metric::histogram,
            Metric::mut_histogram,
            Metric::set_histogram,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ExponentialHistogram>(
            "exponential_histogram",
            Metric::has_exponential_histogram,
            Metric::exponential_histogram,
            Metric::mut_exponential_histogram,
            Metric::set_exponential_histogram,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Summary>(
            "summary",
            Metric::has_summary,
            Metric::summary,
            Metric::mut_summary,
            Metric::set_summary,
        ));
        oneofs.push(metric::Data::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Metric>(
            "Metric",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Metric {
    const NAME: &'static str = "Metric";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                26 => {
                    self.unit = is.read_string()?;
                },
                42 => {
                    self.data = ::std::option::Option::Some(metric::Data::Gauge(is.read_message()?));
                },
                58 => {
                    self.data = ::std::option::Option::Some(metric::Data::Sum(is.read_message()?));
                },
                74 => {
                    self.data = ::std::option::Option::Some(metric::Data::Histogram(is.read_message()?));
                },
                82 => {
                    self.data = ::std::option::Option::Some(metric::Data::ExponentialHistogram(is.read_message()?));
                },
                90 => {
                    self.data = ::std::option::Option::Some(metric::Data::Summary(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.unit.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.unit);
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &metric::Data::Gauge(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &metric::Data::Sum(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &metric::Data::Histogram(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &metric::Data::ExponentialHistogram(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &metric::Data::Summary(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.unit.is_empty() {
            os.write_string(3, &self.unit)?;
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &metric::Data::Gauge(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &metric::Data::Sum(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &metric::Data::Histogram(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &metric::Data::ExponentialHistogram(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &metric::Data::Summary(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Metric {
        Metric::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.unit.clear();
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Metric {
        static instance: Metric = Metric {
            name: ::std::string::String::new(),
            description: ::std::string::String::new(),
            unit: ::std::string::String::new(),
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Metric {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Metric").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Metric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Metric {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Metric`
pub mod metric {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:opentelemetry.proto.collector.metrics.v1.Metric.data)
    pub enum Data {
        // @@protoc_insertion_point(oneof_field:opentelemetry.proto.collector.metrics.v1.Metric.gauge)
        Gauge(super::Gauge),
        // @@protoc_insertion_point(oneof_field:opentelemetry.proto.collector.metrics.v1.Metric.sum)
        Sum(super::Sum),
        // @@protoc_insertion_point(oneof_field:opentelemetry.proto.collector.metrics.v1.Metric.histogram)
        Histogram(super::Histogram),
        // @@protoc_insertion_point(oneof_field:opentelemetry.proto.collector.metrics.v1.Metric.exponential_histogram)
        ExponentialHistogram(super::ExponentialHistogram),
        // @@protoc_insertion_point(oneof_field:opentelemetry.proto.collector.metrics.v1.Metric.summary)
        Summary(super::Summary),
    }

    impl ::protobuf::Oneof for Data {
    }

    impl ::protobuf::OneofFull for Data {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Metric as ::protobuf::MessageFull>::descriptor().oneof_by_name("data").unwrap()).clone()
        }
    }

    impl Data {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Data>("data")
        }
    }
}

///  Gauge represents the type of a scalar metric that always exports the
///  "current value" for every data point. It should be used for an "unknown"
///  aggregation.
///
///  A Gauge does not support different aggregation temporalities. Given the
///  aggregation is unknown, points cannot be combined using the same
///  aggregation, regardless of aggregation temporalities. Therefore,
///  AggregationTemporality is not included. Consequently, this also means
///  "StartTimeUnixNano" is ignored for all data points.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.Gauge)
pub struct Gauge {
    // message fields
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.Gauge.data_points)
    pub data_points: ::std::vec::Vec<NumberDataPoint>,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.Gauge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Gauge {
    fn default() -> &'a Gauge {
        <Gauge as ::protobuf::Message>::default_instance()
    }
}

impl Gauge {
    pub fn new() -> Gauge {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_points",
            |m: &Gauge| { &m.data_points },
            |m: &mut Gauge| { &mut m.data_points },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Gauge>(
            "Gauge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Gauge {
    const NAME: &'static str = "Gauge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data_points.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.data_points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.data_points {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Gauge {
        Gauge::new()
    }

    fn clear(&mut self) {
        self.data_points.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Gauge {
        static instance: Gauge = Gauge {
            data_points: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Gauge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Gauge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Gauge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Gauge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Sum represents the type of a scalar metric that is calculated as a sum of all
///  reported measurements over a time interval.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.Sum)
pub struct Sum {
    // message fields
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.Sum.data_points)
    pub data_points: ::std::vec::Vec<NumberDataPoint>,
    ///  aggregation_temporality describes if the aggregator reports delta changes
    ///  since last report time, or cumulative changes since a fixed start time.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.Sum.aggregation_temporality)
    pub aggregation_temporality: ::protobuf::EnumOrUnknown<AggregationTemporality>,
    ///  If "true" means that the sum is monotonic.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.Sum.is_monotonic)
    pub is_monotonic: bool,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.Sum.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Sum {
    fn default() -> &'a Sum {
        <Sum as ::protobuf::Message>::default_instance()
    }
}

impl Sum {
    pub fn new() -> Sum {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_points",
            |m: &Sum| { &m.data_points },
            |m: &mut Sum| { &mut m.data_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "aggregation_temporality",
            |m: &Sum| { &m.aggregation_temporality },
            |m: &mut Sum| { &mut m.aggregation_temporality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_monotonic",
            |m: &Sum| { &m.is_monotonic },
            |m: &mut Sum| { &mut m.is_monotonic },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sum>(
            "Sum",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Sum {
    const NAME: &'static str = "Sum";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data_points.push(is.read_message()?);
                },
                16 => {
                    self.aggregation_temporality = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.is_monotonic = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.data_points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.aggregation_temporality != ::protobuf::EnumOrUnknown::new(AggregationTemporality::AGGREGATION_TEMPORALITY_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(2, self.aggregation_temporality.value());
        }
        if self.is_monotonic != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.data_points {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.aggregation_temporality != ::protobuf::EnumOrUnknown::new(AggregationTemporality::AGGREGATION_TEMPORALITY_UNSPECIFIED) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.aggregation_temporality))?;
        }
        if self.is_monotonic != false {
            os.write_bool(3, self.is_monotonic)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Sum {
        Sum::new()
    }

    fn clear(&mut self) {
        self.data_points.clear();
        self.aggregation_temporality = ::protobuf::EnumOrUnknown::new(AggregationTemporality::AGGREGATION_TEMPORALITY_UNSPECIFIED);
        self.is_monotonic = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Sum {
        static instance: Sum = Sum {
            data_points: ::std::vec::Vec::new(),
            aggregation_temporality: ::protobuf::EnumOrUnknown::from_i32(0),
            is_monotonic: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Sum {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Sum").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Sum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sum {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Histogram represents the type of a metric that is calculated by aggregating
///  as a Histogram of all reported measurements over a time interval.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.Histogram)
pub struct Histogram {
    // message fields
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.Histogram.data_points)
    pub data_points: ::std::vec::Vec<HistogramDataPoint>,
    ///  aggregation_temporality describes if the aggregator reports delta changes
    ///  since last report time, or cumulative changes since a fixed start time.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.Histogram.aggregation_temporality)
    pub aggregation_temporality: ::protobuf::EnumOrUnknown<AggregationTemporality>,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.Histogram.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Histogram {
    fn default() -> &'a Histogram {
        <Histogram as ::protobuf::Message>::default_instance()
    }
}

impl Histogram {
    pub fn new() -> Histogram {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_points",
            |m: &Histogram| { &m.data_points },
            |m: &mut Histogram| { &mut m.data_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "aggregation_temporality",
            |m: &Histogram| { &m.aggregation_temporality },
            |m: &mut Histogram| { &mut m.aggregation_temporality },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Histogram>(
            "Histogram",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Histogram {
    const NAME: &'static str = "Histogram";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data_points.push(is.read_message()?);
                },
                16 => {
                    self.aggregation_temporality = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.data_points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.aggregation_temporality != ::protobuf::EnumOrUnknown::new(AggregationTemporality::AGGREGATION_TEMPORALITY_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(2, self.aggregation_temporality.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.data_points {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.aggregation_temporality != ::protobuf::EnumOrUnknown::new(AggregationTemporality::AGGREGATION_TEMPORALITY_UNSPECIFIED) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.aggregation_temporality))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Histogram {
        Histogram::new()
    }

    fn clear(&mut self) {
        self.data_points.clear();
        self.aggregation_temporality = ::protobuf::EnumOrUnknown::new(AggregationTemporality::AGGREGATION_TEMPORALITY_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Histogram {
        static instance: Histogram = Histogram {
            data_points: ::std::vec::Vec::new(),
            aggregation_temporality: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Histogram {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Histogram").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Histogram {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Histogram {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ExponentialHistogram represents the type of a metric that is calculated by aggregating
///  as a ExponentialHistogram of all reported double measurements over a time interval.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.ExponentialHistogram)
pub struct ExponentialHistogram {
    // message fields
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogram.data_points)
    pub data_points: ::std::vec::Vec<ExponentialHistogramDataPoint>,
    ///  aggregation_temporality describes if the aggregator reports delta changes
    ///  since last report time, or cumulative changes since a fixed start time.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogram.aggregation_temporality)
    pub aggregation_temporality: ::protobuf::EnumOrUnknown<AggregationTemporality>,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogram.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExponentialHistogram {
    fn default() -> &'a ExponentialHistogram {
        <ExponentialHistogram as ::protobuf::Message>::default_instance()
    }
}

impl ExponentialHistogram {
    pub fn new() -> ExponentialHistogram {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_points",
            |m: &ExponentialHistogram| { &m.data_points },
            |m: &mut ExponentialHistogram| { &mut m.data_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "aggregation_temporality",
            |m: &ExponentialHistogram| { &m.aggregation_temporality },
            |m: &mut ExponentialHistogram| { &mut m.aggregation_temporality },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExponentialHistogram>(
            "ExponentialHistogram",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExponentialHistogram {
    const NAME: &'static str = "ExponentialHistogram";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data_points.push(is.read_message()?);
                },
                16 => {
                    self.aggregation_temporality = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.data_points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.aggregation_temporality != ::protobuf::EnumOrUnknown::new(AggregationTemporality::AGGREGATION_TEMPORALITY_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(2, self.aggregation_temporality.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.data_points {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.aggregation_temporality != ::protobuf::EnumOrUnknown::new(AggregationTemporality::AGGREGATION_TEMPORALITY_UNSPECIFIED) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.aggregation_temporality))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExponentialHistogram {
        ExponentialHistogram::new()
    }

    fn clear(&mut self) {
        self.data_points.clear();
        self.aggregation_temporality = ::protobuf::EnumOrUnknown::new(AggregationTemporality::AGGREGATION_TEMPORALITY_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExponentialHistogram {
        static instance: ExponentialHistogram = ExponentialHistogram {
            data_points: ::std::vec::Vec::new(),
            aggregation_temporality: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExponentialHistogram {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExponentialHistogram").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExponentialHistogram {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExponentialHistogram {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Summary metric data are used to convey quantile summaries,
///  a Prometheus (see: https://prometheus.io/docs/concepts/metric_types/#summary)
///  and OpenMetrics (see: https://github.com/OpenObservability/OpenMetrics/blob/4dbf6075567ab43296eed941037c12951faafb92/protos/prometheus.proto#L45)
///  data type. These data points cannot always be merged in a meaningful way.
///  While they can be useful in some applications, histogram data points are
///  recommended for new applications.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.Summary)
pub struct Summary {
    // message fields
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.Summary.data_points)
    pub data_points: ::std::vec::Vec<SummaryDataPoint>,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.Summary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Summary {
    fn default() -> &'a Summary {
        <Summary as ::protobuf::Message>::default_instance()
    }
}

impl Summary {
    pub fn new() -> Summary {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_points",
            |m: &Summary| { &m.data_points },
            |m: &mut Summary| { &mut m.data_points },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Summary>(
            "Summary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Summary {
    const NAME: &'static str = "Summary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data_points.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.data_points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.data_points {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Summary {
        Summary::new()
    }

    fn clear(&mut self) {
        self.data_points.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Summary {
        static instance: Summary = Summary {
            data_points: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Summary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Summary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Summary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Summary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  NumberDataPoint is a single data point in a timeseries that describes the
///  time-varying scalar value of a metric.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.NumberDataPoint)
pub struct NumberDataPoint {
    // message fields
    ///  The set of key/value pairs that uniquely identify the timeseries from
    ///  where this point belongs. The list may be empty (may contain 0 elements).
    ///  Attribute keys MUST be unique (it is not allowed to have more than one
    ///  attribute with the same key).
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.NumberDataPoint.attributes)
    pub attributes: ::std::vec::Vec<KeyValue>,
    ///  StartTimeUnixNano is optional but strongly encouraged, see the
    ///  the detailed comments above Metric.
    ///
    ///  Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    ///  1970.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.NumberDataPoint.start_time_unix_nano)
    pub start_time_unix_nano: u64,
    ///  TimeUnixNano is required, see the detailed comments above Metric.
    ///
    ///  Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    ///  1970.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.NumberDataPoint.time_unix_nano)
    pub time_unix_nano: u64,
    ///  (Optional) List of exemplars collected from
    ///  measurements that were used to form the data point
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.NumberDataPoint.exemplars)
    pub exemplars: ::std::vec::Vec<Exemplar>,
    ///  Flags that apply to this specific data point.  See DataPointFlags
    ///  for the available flags and their meaning.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.NumberDataPoint.flags)
    pub flags: u32,
    // message oneof groups
    pub value: ::std::option::Option<number_data_point::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.NumberDataPoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NumberDataPoint {
    fn default() -> &'a NumberDataPoint {
        <NumberDataPoint as ::protobuf::Message>::default_instance()
    }
}

impl NumberDataPoint {
    pub fn new() -> NumberDataPoint {
        ::std::default::Default::default()
    }

    // double as_double = 4;

    pub fn as_double(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(number_data_point::Value::AsDouble(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_as_double(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_as_double(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(number_data_point::Value::AsDouble(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_as_double(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(number_data_point::Value::AsDouble(v))
    }

    // sfixed64 as_int = 6;

    pub fn as_int(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(number_data_point::Value::AsInt(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_as_int(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_as_int(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(number_data_point::Value::AsInt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_as_int(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(number_data_point::Value::AsInt(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attributes",
            |m: &NumberDataPoint| { &m.attributes },
            |m: &mut NumberDataPoint| { &mut m.attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_time_unix_nano",
            |m: &NumberDataPoint| { &m.start_time_unix_nano },
            |m: &mut NumberDataPoint| { &mut m.start_time_unix_nano },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time_unix_nano",
            |m: &NumberDataPoint| { &m.time_unix_nano },
            |m: &mut NumberDataPoint| { &mut m.time_unix_nano },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "as_double",
            NumberDataPoint::has_as_double,
            NumberDataPoint::as_double,
            NumberDataPoint::set_as_double,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "as_int",
            NumberDataPoint::has_as_int,
            NumberDataPoint::as_int,
            NumberDataPoint::set_as_int,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exemplars",
            |m: &NumberDataPoint| { &m.exemplars },
            |m: &mut NumberDataPoint| { &mut m.exemplars },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "flags",
            |m: &NumberDataPoint| { &m.flags },
            |m: &mut NumberDataPoint| { &mut m.flags },
        ));
        oneofs.push(number_data_point::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NumberDataPoint>(
            "NumberDataPoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NumberDataPoint {
    const NAME: &'static str = "NumberDataPoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                58 => {
                    self.attributes.push(is.read_message()?);
                },
                17 => {
                    self.start_time_unix_nano = is.read_fixed64()?;
                },
                25 => {
                    self.time_unix_nano = is.read_fixed64()?;
                },
                33 => {
                    self.value = ::std::option::Option::Some(number_data_point::Value::AsDouble(is.read_double()?));
                },
                49 => {
                    self.value = ::std::option::Option::Some(number_data_point::Value::AsInt(is.read_sfixed64()?));
                },
                42 => {
                    self.exemplars.push(is.read_message()?);
                },
                64 => {
                    self.flags = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.start_time_unix_nano != 0 {
            my_size += 1 + 8;
        }
        if self.time_unix_nano != 0 {
            my_size += 1 + 8;
        }
        for value in &self.exemplars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.flags != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.flags);
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &number_data_point::Value::AsDouble(v) => {
                    my_size += 1 + 8;
                },
                &number_data_point::Value::AsInt(v) => {
                    my_size += 1 + 8;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.attributes {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if self.start_time_unix_nano != 0 {
            os.write_fixed64(2, self.start_time_unix_nano)?;
        }
        if self.time_unix_nano != 0 {
            os.write_fixed64(3, self.time_unix_nano)?;
        }
        for v in &self.exemplars {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.flags != 0 {
            os.write_uint32(8, self.flags)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &number_data_point::Value::AsDouble(v) => {
                    os.write_double(4, v)?;
                },
                &number_data_point::Value::AsInt(v) => {
                    os.write_sfixed64(6, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NumberDataPoint {
        NumberDataPoint::new()
    }

    fn clear(&mut self) {
        self.attributes.clear();
        self.start_time_unix_nano = 0;
        self.time_unix_nano = 0;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.exemplars.clear();
        self.flags = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NumberDataPoint {
        static instance: NumberDataPoint = NumberDataPoint {
            attributes: ::std::vec::Vec::new(),
            start_time_unix_nano: 0,
            time_unix_nano: 0,
            exemplars: ::std::vec::Vec::new(),
            flags: 0,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NumberDataPoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NumberDataPoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NumberDataPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NumberDataPoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NumberDataPoint`
pub mod number_data_point {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:opentelemetry.proto.collector.metrics.v1.NumberDataPoint.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:opentelemetry.proto.collector.metrics.v1.NumberDataPoint.as_double)
        AsDouble(f64),
        // @@protoc_insertion_point(oneof_field:opentelemetry.proto.collector.metrics.v1.NumberDataPoint.as_int)
        AsInt(i64),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::NumberDataPoint as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
}

///  HistogramDataPoint is a single data point in a timeseries that describes the
///  time-varying values of a Histogram. A Histogram contains summary statistics
///  for a population of values, it may optionally contain the distribution of
///  those values across a set of buckets.
///
///  If the histogram contains the distribution of values, then both
///  "explicit_bounds" and "bucket counts" fields must be defined.
///  If the histogram does not contain the distribution of values, then both
///  "explicit_bounds" and "bucket_counts" must be omitted and only "count" and
///  "sum" are known.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.HistogramDataPoint)
pub struct HistogramDataPoint {
    // message fields
    ///  The set of key/value pairs that uniquely identify the timeseries from
    ///  where this point belongs. The list may be empty (may contain 0 elements).
    ///  Attribute keys MUST be unique (it is not allowed to have more than one
    ///  attribute with the same key).
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.HistogramDataPoint.attributes)
    pub attributes: ::std::vec::Vec<KeyValue>,
    ///  StartTimeUnixNano is optional but strongly encouraged, see the
    ///  the detailed comments above Metric.
    ///
    ///  Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    ///  1970.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.HistogramDataPoint.start_time_unix_nano)
    pub start_time_unix_nano: u64,
    ///  TimeUnixNano is required, see the detailed comments above Metric.
    ///
    ///  Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    ///  1970.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.HistogramDataPoint.time_unix_nano)
    pub time_unix_nano: u64,
    ///  count is the number of values in the population. Must be non-negative. This
    ///  value must be equal to the sum of the "count" fields in buckets if a
    ///  histogram is provided.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.HistogramDataPoint.count)
    pub count: u64,
    ///  sum of the values in the population. If count is zero then this field
    ///  must be zero.
    ///
    ///  Note: Sum should only be filled out when measuring non-negative discrete
    ///  events, and is assumed to be monotonic over the values of these events.
    ///  Negative events *can* be recorded, but sum should not be filled out when
    ///  doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
    ///  see: https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#histogram
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.HistogramDataPoint.sum)
    pub sum: ::std::option::Option<f64>,
    ///  bucket_counts is an optional field contains the count values of histogram
    ///  for each bucket.
    ///
    ///  The sum of the bucket_counts must equal the value in the count field.
    ///
    ///  The number of elements in bucket_counts array must be by one greater than
    ///  the number of elements in explicit_bounds array.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.HistogramDataPoint.bucket_counts)
    pub bucket_counts: ::std::vec::Vec<u64>,
    ///  explicit_bounds specifies buckets with explicitly defined bounds for values.
    ///
    ///  The boundaries for bucket at index i are:
    ///
    ///  (-infinity, explicit_bounds[i]] for i == 0
    ///  (explicit_bounds[i-1], explicit_bounds[i]] for 0 < i < size(explicit_bounds)
    ///  (explicit_bounds[i-1], +infinity) for i == size(explicit_bounds)
    ///
    ///  The values in the explicit_bounds array must be strictly increasing.
    ///
    ///  Histogram buckets are inclusive of their upper boundary, except the last
    ///  bucket where the boundary is at infinity. This format is intentionally
    ///  compatible with the OpenMetrics histogram definition.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.HistogramDataPoint.explicit_bounds)
    pub explicit_bounds: ::std::vec::Vec<f64>,
    ///  (Optional) List of exemplars collected from
    ///  measurements that were used to form the data point
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.HistogramDataPoint.exemplars)
    pub exemplars: ::std::vec::Vec<Exemplar>,
    ///  Flags that apply to this specific data point.  See DataPointFlags
    ///  for the available flags and their meaning.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.HistogramDataPoint.flags)
    pub flags: u32,
    ///  min is the minimum value over (start_time, end_time].
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.HistogramDataPoint.min)
    pub min: ::std::option::Option<f64>,
    ///  max is the maximum value over (start_time, end_time].
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.HistogramDataPoint.max)
    pub max: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.HistogramDataPoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HistogramDataPoint {
    fn default() -> &'a HistogramDataPoint {
        <HistogramDataPoint as ::protobuf::Message>::default_instance()
    }
}

impl HistogramDataPoint {
    pub fn new() -> HistogramDataPoint {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attributes",
            |m: &HistogramDataPoint| { &m.attributes },
            |m: &mut HistogramDataPoint| { &mut m.attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_time_unix_nano",
            |m: &HistogramDataPoint| { &m.start_time_unix_nano },
            |m: &mut HistogramDataPoint| { &mut m.start_time_unix_nano },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time_unix_nano",
            |m: &HistogramDataPoint| { &m.time_unix_nano },
            |m: &mut HistogramDataPoint| { &mut m.time_unix_nano },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &HistogramDataPoint| { &m.count },
            |m: &mut HistogramDataPoint| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sum",
            |m: &HistogramDataPoint| { &m.sum },
            |m: &mut HistogramDataPoint| { &mut m.sum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bucket_counts",
            |m: &HistogramDataPoint| { &m.bucket_counts },
            |m: &mut HistogramDataPoint| { &mut m.bucket_counts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "explicit_bounds",
            |m: &HistogramDataPoint| { &m.explicit_bounds },
            |m: &mut HistogramDataPoint| { &mut m.explicit_bounds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exemplars",
            |m: &HistogramDataPoint| { &m.exemplars },
            |m: &mut HistogramDataPoint| { &mut m.exemplars },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "flags",
            |m: &HistogramDataPoint| { &m.flags },
            |m: &mut HistogramDataPoint| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min",
            |m: &HistogramDataPoint| { &m.min },
            |m: &mut HistogramDataPoint| { &mut m.min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max",
            |m: &HistogramDataPoint| { &m.max },
            |m: &mut HistogramDataPoint| { &mut m.max },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HistogramDataPoint>(
            "HistogramDataPoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HistogramDataPoint {
    const NAME: &'static str = "HistogramDataPoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                74 => {
                    self.attributes.push(is.read_message()?);
                },
                17 => {
                    self.start_time_unix_nano = is.read_fixed64()?;
                },
                25 => {
                    self.time_unix_nano = is.read_fixed64()?;
                },
                33 => {
                    self.count = is.read_fixed64()?;
                },
                41 => {
                    self.sum = ::std::option::Option::Some(is.read_double()?);
                },
                50 => {
                    is.read_repeated_packed_fixed64_into(&mut self.bucket_counts)?;
                },
                49 => {
                    self.bucket_counts.push(is.read_fixed64()?);
                },
                58 => {
                    is.read_repeated_packed_double_into(&mut self.explicit_bounds)?;
                },
                57 => {
                    self.explicit_bounds.push(is.read_double()?);
                },
                66 => {
                    self.exemplars.push(is.read_message()?);
                },
                80 => {
                    self.flags = is.read_uint32()?;
                },
                89 => {
                    self.min = ::std::option::Option::Some(is.read_double()?);
                },
                97 => {
                    self.max = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.start_time_unix_nano != 0 {
            my_size += 1 + 8;
        }
        if self.time_unix_nano != 0 {
            my_size += 1 + 8;
        }
        if self.count != 0 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.sum {
            my_size += 1 + 8;
        }
        my_size += 9 * self.bucket_counts.len() as u64;
        my_size += 9 * self.explicit_bounds.len() as u64;
        for value in &self.exemplars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.flags != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.flags);
        }
        if let Some(v) = self.min {
            my_size += 1 + 8;
        }
        if let Some(v) = self.max {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.attributes {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if self.start_time_unix_nano != 0 {
            os.write_fixed64(2, self.start_time_unix_nano)?;
        }
        if self.time_unix_nano != 0 {
            os.write_fixed64(3, self.time_unix_nano)?;
        }
        if self.count != 0 {
            os.write_fixed64(4, self.count)?;
        }
        if let Some(v) = self.sum {
            os.write_double(5, v)?;
        }
        for v in &self.bucket_counts {
            os.write_fixed64(6, *v)?;
        };
        for v in &self.explicit_bounds {
            os.write_double(7, *v)?;
        };
        for v in &self.exemplars {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if self.flags != 0 {
            os.write_uint32(10, self.flags)?;
        }
        if let Some(v) = self.min {
            os.write_double(11, v)?;
        }
        if let Some(v) = self.max {
            os.write_double(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HistogramDataPoint {
        HistogramDataPoint::new()
    }

    fn clear(&mut self) {
        self.attributes.clear();
        self.start_time_unix_nano = 0;
        self.time_unix_nano = 0;
        self.count = 0;
        self.sum = ::std::option::Option::None;
        self.bucket_counts.clear();
        self.explicit_bounds.clear();
        self.exemplars.clear();
        self.flags = 0;
        self.min = ::std::option::Option::None;
        self.max = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HistogramDataPoint {
        static instance: HistogramDataPoint = HistogramDataPoint {
            attributes: ::std::vec::Vec::new(),
            start_time_unix_nano: 0,
            time_unix_nano: 0,
            count: 0,
            sum: ::std::option::Option::None,
            bucket_counts: ::std::vec::Vec::new(),
            explicit_bounds: ::std::vec::Vec::new(),
            exemplars: ::std::vec::Vec::new(),
            flags: 0,
            min: ::std::option::Option::None,
            max: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HistogramDataPoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HistogramDataPoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HistogramDataPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HistogramDataPoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ExponentialHistogramDataPoint is a single data point in a timeseries that describes the
///  time-varying values of a ExponentialHistogram of double values. A ExponentialHistogram contains
///  summary statistics for a population of values, it may optionally contain the
///  distribution of those values across a set of buckets.
///
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint)
pub struct ExponentialHistogramDataPoint {
    // message fields
    ///  The set of key/value pairs that uniquely identify the timeseries from
    ///  where this point belongs. The list may be empty (may contain 0 elements).
    ///  Attribute keys MUST be unique (it is not allowed to have more than one
    ///  attribute with the same key).
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.attributes)
    pub attributes: ::std::vec::Vec<KeyValue>,
    ///  StartTimeUnixNano is optional but strongly encouraged, see the
    ///  the detailed comments above Metric.
    ///
    ///  Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    ///  1970.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.start_time_unix_nano)
    pub start_time_unix_nano: u64,
    ///  TimeUnixNano is required, see the detailed comments above Metric.
    ///
    ///  Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    ///  1970.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.time_unix_nano)
    pub time_unix_nano: u64,
    ///  count is the number of values in the population. Must be
    ///  non-negative. This value must be equal to the sum of the "bucket_counts"
    ///  values in the positive and negative Buckets plus the "zero_count" field.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.count)
    pub count: u64,
    ///  sum of the values in the population. If count is zero then this field
    ///  must be zero.
    ///
    ///  Note: Sum should only be filled out when measuring non-negative discrete
    ///  events, and is assumed to be monotonic over the values of these events.
    ///  Negative events *can* be recorded, but sum should not be filled out when
    ///  doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
    ///  see: https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#histogram
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.sum)
    pub sum: ::std::option::Option<f64>,
    ///  scale describes the resolution of the histogram.  Boundaries are
    ///  located at powers of the base, where:
    ///
    ///    base = (2^(2^-scale))
    ///
    ///  The histogram bucket identified by `index`, a signed integer,
    ///  contains values that are greater than or equal to (base^index) and
    ///  less than (base^(index+1)).
    ///
    ///  The positive and negative ranges of the histogram are expressed
    ///  separately.  Negative values are mapped by their absolute value
    ///  into the negative range using the same scale as the positive range.
    ///
    ///  scale is not restricted by the protocol, as the permissible
    ///  values depend on the range of the data.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.scale)
    pub scale: i32,
    ///  zero_count is the count of values that are either exactly zero or
    ///  within the region considered zero by the instrumentation at the
    ///  tolerated degree of precision.  This bucket stores values that
    ///  cannot be expressed using the standard exponential formula as
    ///  well as values that have been rounded to zero.
    ///
    ///  Implementations MAY consider the zero bucket to have probability
    ///  mass equal to (zero_count / count).
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.zero_count)
    pub zero_count: u64,
    ///  positive carries the positive range of exponential bucket counts.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.positive)
    pub positive: ::protobuf::MessageField<exponential_histogram_data_point::Buckets>,
    ///  negative carries the negative range of exponential bucket counts.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.negative)
    pub negative: ::protobuf::MessageField<exponential_histogram_data_point::Buckets>,
    ///  Flags that apply to this specific data point.  See DataPointFlags
    ///  for the available flags and their meaning.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.flags)
    pub flags: u32,
    ///  (Optional) List of exemplars collected from
    ///  measurements that were used to form the data point
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.exemplars)
    pub exemplars: ::std::vec::Vec<Exemplar>,
    ///  min is the minimum value over (start_time, end_time].
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.min)
    pub min: ::std::option::Option<f64>,
    ///  max is the maximum value over (start_time, end_time].
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.max)
    pub max: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExponentialHistogramDataPoint {
    fn default() -> &'a ExponentialHistogramDataPoint {
        <ExponentialHistogramDataPoint as ::protobuf::Message>::default_instance()
    }
}

impl ExponentialHistogramDataPoint {
    pub fn new() -> ExponentialHistogramDataPoint {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attributes",
            |m: &ExponentialHistogramDataPoint| { &m.attributes },
            |m: &mut ExponentialHistogramDataPoint| { &mut m.attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_time_unix_nano",
            |m: &ExponentialHistogramDataPoint| { &m.start_time_unix_nano },
            |m: &mut ExponentialHistogramDataPoint| { &mut m.start_time_unix_nano },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time_unix_nano",
            |m: &ExponentialHistogramDataPoint| { &m.time_unix_nano },
            |m: &mut ExponentialHistogramDataPoint| { &mut m.time_unix_nano },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &ExponentialHistogramDataPoint| { &m.count },
            |m: &mut ExponentialHistogramDataPoint| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sum",
            |m: &ExponentialHistogramDataPoint| { &m.sum },
            |m: &mut ExponentialHistogramDataPoint| { &mut m.sum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "scale",
            |m: &ExponentialHistogramDataPoint| { &m.scale },
            |m: &mut ExponentialHistogramDataPoint| { &mut m.scale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "zero_count",
            |m: &ExponentialHistogramDataPoint| { &m.zero_count },
            |m: &mut ExponentialHistogramDataPoint| { &mut m.zero_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, exponential_histogram_data_point::Buckets>(
            "positive",
            |m: &ExponentialHistogramDataPoint| { &m.positive },
            |m: &mut ExponentialHistogramDataPoint| { &mut m.positive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, exponential_histogram_data_point::Buckets>(
            "negative",
            |m: &ExponentialHistogramDataPoint| { &m.negative },
            |m: &mut ExponentialHistogramDataPoint| { &mut m.negative },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "flags",
            |m: &ExponentialHistogramDataPoint| { &m.flags },
            |m: &mut ExponentialHistogramDataPoint| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exemplars",
            |m: &ExponentialHistogramDataPoint| { &m.exemplars },
            |m: &mut ExponentialHistogramDataPoint| { &mut m.exemplars },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min",
            |m: &ExponentialHistogramDataPoint| { &m.min },
            |m: &mut ExponentialHistogramDataPoint| { &mut m.min },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max",
            |m: &ExponentialHistogramDataPoint| { &m.max },
            |m: &mut ExponentialHistogramDataPoint| { &mut m.max },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExponentialHistogramDataPoint>(
            "ExponentialHistogramDataPoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExponentialHistogramDataPoint {
    const NAME: &'static str = "ExponentialHistogramDataPoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.attributes.push(is.read_message()?);
                },
                17 => {
                    self.start_time_unix_nano = is.read_fixed64()?;
                },
                25 => {
                    self.time_unix_nano = is.read_fixed64()?;
                },
                33 => {
                    self.count = is.read_fixed64()?;
                },
                41 => {
                    self.sum = ::std::option::Option::Some(is.read_double()?);
                },
                48 => {
                    self.scale = is.read_sint32()?;
                },
                57 => {
                    self.zero_count = is.read_fixed64()?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.positive)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.negative)?;
                },
                80 => {
                    self.flags = is.read_uint32()?;
                },
                90 => {
                    self.exemplars.push(is.read_message()?);
                },
                97 => {
                    self.min = ::std::option::Option::Some(is.read_double()?);
                },
                105 => {
                    self.max = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.start_time_unix_nano != 0 {
            my_size += 1 + 8;
        }
        if self.time_unix_nano != 0 {
            my_size += 1 + 8;
        }
        if self.count != 0 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.sum {
            my_size += 1 + 8;
        }
        if self.scale != 0 {
            my_size += ::protobuf::rt::sint32_size(6, self.scale);
        }
        if self.zero_count != 0 {
            my_size += 1 + 8;
        }
        if let Some(v) = self.positive.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.negative.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.flags != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.flags);
        }
        for value in &self.exemplars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.min {
            my_size += 1 + 8;
        }
        if let Some(v) = self.max {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.attributes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.start_time_unix_nano != 0 {
            os.write_fixed64(2, self.start_time_unix_nano)?;
        }
        if self.time_unix_nano != 0 {
            os.write_fixed64(3, self.time_unix_nano)?;
        }
        if self.count != 0 {
            os.write_fixed64(4, self.count)?;
        }
        if let Some(v) = self.sum {
            os.write_double(5, v)?;
        }
        if self.scale != 0 {
            os.write_sint32(6, self.scale)?;
        }
        if self.zero_count != 0 {
            os.write_fixed64(7, self.zero_count)?;
        }
        if let Some(v) = self.positive.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.negative.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if self.flags != 0 {
            os.write_uint32(10, self.flags)?;
        }
        for v in &self.exemplars {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.min {
            os.write_double(12, v)?;
        }
        if let Some(v) = self.max {
            os.write_double(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExponentialHistogramDataPoint {
        ExponentialHistogramDataPoint::new()
    }

    fn clear(&mut self) {
        self.attributes.clear();
        self.start_time_unix_nano = 0;
        self.time_unix_nano = 0;
        self.count = 0;
        self.sum = ::std::option::Option::None;
        self.scale = 0;
        self.zero_count = 0;
        self.positive.clear();
        self.negative.clear();
        self.flags = 0;
        self.exemplars.clear();
        self.min = ::std::option::Option::None;
        self.max = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExponentialHistogramDataPoint {
        static instance: ExponentialHistogramDataPoint = ExponentialHistogramDataPoint {
            attributes: ::std::vec::Vec::new(),
            start_time_unix_nano: 0,
            time_unix_nano: 0,
            count: 0,
            sum: ::std::option::Option::None,
            scale: 0,
            zero_count: 0,
            positive: ::protobuf::MessageField::none(),
            negative: ::protobuf::MessageField::none(),
            flags: 0,
            exemplars: ::std::vec::Vec::new(),
            min: ::std::option::Option::None,
            max: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExponentialHistogramDataPoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExponentialHistogramDataPoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExponentialHistogramDataPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExponentialHistogramDataPoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ExponentialHistogramDataPoint`
pub mod exponential_histogram_data_point {
    ///  Buckets are a set of bucket counts, encoded in a contiguous array
    ///  of counts.
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.Buckets)
    pub struct Buckets {
        // message fields
        ///  Offset is the bucket index of the first entry in the bucket_counts array.
        ///
        ///  Note: This uses a varint encoding as a simple form of compression.
        // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.Buckets.offset)
        pub offset: i32,
        ///  Count is an array of counts, where count[i] carries the count
        ///  of the bucket at index (offset+i).  count[i] is the count of
        ///  values greater than or equal to base^(offset+i) and less than
        ///  base^(offset+i+1).
        ///
        ///  Note: By contrast, the explicit HistogramDataPoint uses
        ///  fixed64.  This field is expected to have many buckets,
        ///  especially zeros, so uint64 has been selected to ensure
        ///  varint encoding.
        // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.Buckets.bucket_counts)
        pub bucket_counts: ::std::vec::Vec<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.ExponentialHistogramDataPoint.Buckets.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Buckets {
        fn default() -> &'a Buckets {
            <Buckets as ::protobuf::Message>::default_instance()
        }
    }

    impl Buckets {
        pub fn new() -> Buckets {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "offset",
                |m: &Buckets| { &m.offset },
                |m: &mut Buckets| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "bucket_counts",
                |m: &Buckets| { &m.bucket_counts },
                |m: &mut Buckets| { &mut m.bucket_counts },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Buckets>(
                "ExponentialHistogramDataPoint.Buckets",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Buckets {
        const NAME: &'static str = "Buckets";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.offset = is.read_sint32()?;
                    },
                    18 => {
                        is.read_repeated_packed_uint64_into(&mut self.bucket_counts)?;
                    },
                    16 => {
                        self.bucket_counts.push(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.offset != 0 {
                my_size += ::protobuf::rt::sint32_size(1, self.offset);
            }
            for value in &self.bucket_counts {
                my_size += ::protobuf::rt::uint64_size(2, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.offset != 0 {
                os.write_sint32(1, self.offset)?;
            }
            for v in &self.bucket_counts {
                os.write_uint64(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Buckets {
            Buckets::new()
        }

        fn clear(&mut self) {
            self.offset = 0;
            self.bucket_counts.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Buckets {
            static instance: Buckets = Buckets {
                offset: 0,
                bucket_counts: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Buckets {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExponentialHistogramDataPoint.Buckets").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Buckets {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Buckets {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  SummaryDataPoint is a single data point in a timeseries that describes the
///  time-varying values of a Summary metric.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.SummaryDataPoint)
pub struct SummaryDataPoint {
    // message fields
    ///  The set of key/value pairs that uniquely identify the timeseries from
    ///  where this point belongs. The list may be empty (may contain 0 elements).
    ///  Attribute keys MUST be unique (it is not allowed to have more than one
    ///  attribute with the same key).
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.SummaryDataPoint.attributes)
    pub attributes: ::std::vec::Vec<KeyValue>,
    ///  StartTimeUnixNano is optional but strongly encouraged, see the
    ///  the detailed comments above Metric.
    ///
    ///  Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    ///  1970.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.SummaryDataPoint.start_time_unix_nano)
    pub start_time_unix_nano: u64,
    ///  TimeUnixNano is required, see the detailed comments above Metric.
    ///
    ///  Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    ///  1970.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.SummaryDataPoint.time_unix_nano)
    pub time_unix_nano: u64,
    ///  count is the number of values in the population. Must be non-negative.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.SummaryDataPoint.count)
    pub count: u64,
    ///  sum of the values in the population. If count is zero then this field
    ///  must be zero.
    ///
    ///  Note: Sum should only be filled out when measuring non-negative discrete
    ///  events, and is assumed to be monotonic over the values of these events.
    ///  Negative events *can* be recorded, but sum should not be filled out when
    ///  doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
    ///  see: https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#summary
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.SummaryDataPoint.sum)
    pub sum: f64,
    ///  (Optional) list of values at different quantiles of the distribution calculated
    ///  from the current snapshot. The quantiles must be strictly increasing.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.SummaryDataPoint.quantile_values)
    pub quantile_values: ::std::vec::Vec<summary_data_point::ValueAtQuantile>,
    ///  Flags that apply to this specific data point.  See DataPointFlags
    ///  for the available flags and their meaning.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.SummaryDataPoint.flags)
    pub flags: u32,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.SummaryDataPoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SummaryDataPoint {
    fn default() -> &'a SummaryDataPoint {
        <SummaryDataPoint as ::protobuf::Message>::default_instance()
    }
}

impl SummaryDataPoint {
    pub fn new() -> SummaryDataPoint {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attributes",
            |m: &SummaryDataPoint| { &m.attributes },
            |m: &mut SummaryDataPoint| { &mut m.attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_time_unix_nano",
            |m: &SummaryDataPoint| { &m.start_time_unix_nano },
            |m: &mut SummaryDataPoint| { &mut m.start_time_unix_nano },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time_unix_nano",
            |m: &SummaryDataPoint| { &m.time_unix_nano },
            |m: &mut SummaryDataPoint| { &mut m.time_unix_nano },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &SummaryDataPoint| { &m.count },
            |m: &mut SummaryDataPoint| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sum",
            |m: &SummaryDataPoint| { &m.sum },
            |m: &mut SummaryDataPoint| { &mut m.sum },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "quantile_values",
            |m: &SummaryDataPoint| { &m.quantile_values },
            |m: &mut SummaryDataPoint| { &mut m.quantile_values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "flags",
            |m: &SummaryDataPoint| { &m.flags },
            |m: &mut SummaryDataPoint| { &mut m.flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SummaryDataPoint>(
            "SummaryDataPoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SummaryDataPoint {
    const NAME: &'static str = "SummaryDataPoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                58 => {
                    self.attributes.push(is.read_message()?);
                },
                17 => {
                    self.start_time_unix_nano = is.read_fixed64()?;
                },
                25 => {
                    self.time_unix_nano = is.read_fixed64()?;
                },
                33 => {
                    self.count = is.read_fixed64()?;
                },
                41 => {
                    self.sum = is.read_double()?;
                },
                50 => {
                    self.quantile_values.push(is.read_message()?);
                },
                64 => {
                    self.flags = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.start_time_unix_nano != 0 {
            my_size += 1 + 8;
        }
        if self.time_unix_nano != 0 {
            my_size += 1 + 8;
        }
        if self.count != 0 {
            my_size += 1 + 8;
        }
        if self.sum != 0. {
            my_size += 1 + 8;
        }
        for value in &self.quantile_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.flags != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.flags);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.attributes {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if self.start_time_unix_nano != 0 {
            os.write_fixed64(2, self.start_time_unix_nano)?;
        }
        if self.time_unix_nano != 0 {
            os.write_fixed64(3, self.time_unix_nano)?;
        }
        if self.count != 0 {
            os.write_fixed64(4, self.count)?;
        }
        if self.sum != 0. {
            os.write_double(5, self.sum)?;
        }
        for v in &self.quantile_values {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if self.flags != 0 {
            os.write_uint32(8, self.flags)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SummaryDataPoint {
        SummaryDataPoint::new()
    }

    fn clear(&mut self) {
        self.attributes.clear();
        self.start_time_unix_nano = 0;
        self.time_unix_nano = 0;
        self.count = 0;
        self.sum = 0.;
        self.quantile_values.clear();
        self.flags = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SummaryDataPoint {
        static instance: SummaryDataPoint = SummaryDataPoint {
            attributes: ::std::vec::Vec::new(),
            start_time_unix_nano: 0,
            time_unix_nano: 0,
            count: 0,
            sum: 0.,
            quantile_values: ::std::vec::Vec::new(),
            flags: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SummaryDataPoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SummaryDataPoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SummaryDataPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SummaryDataPoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SummaryDataPoint`
pub mod summary_data_point {
    ///  Represents the value at a given quantile of a distribution.
    ///
    ///  To record Min and Max values following conventions are used:
    ///  - The 1.0 quantile is equivalent to the maximum value observed.
    ///  - The 0.0 quantile is equivalent to the minimum value observed.
    ///
    ///  See the following issue for more context:
    ///  https://github.com/open-telemetry/opentelemetry-proto/issues/125
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.SummaryDataPoint.ValueAtQuantile)
    pub struct ValueAtQuantile {
        // message fields
        ///  The quantile of a distribution. Must be in the interval
        ///  [0.0, 1.0].
        // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.SummaryDataPoint.ValueAtQuantile.quantile)
        pub quantile: f64,
        ///  The value at the given quantile of a distribution.
        ///
        ///  Quantile values must NOT be negative.
        // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.SummaryDataPoint.ValueAtQuantile.value)
        pub value: f64,
        // special fields
        // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.SummaryDataPoint.ValueAtQuantile.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ValueAtQuantile {
        fn default() -> &'a ValueAtQuantile {
            <ValueAtQuantile as ::protobuf::Message>::default_instance()
        }
    }

    impl ValueAtQuantile {
        pub fn new() -> ValueAtQuantile {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "quantile",
                |m: &ValueAtQuantile| { &m.quantile },
                |m: &mut ValueAtQuantile| { &mut m.quantile },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &ValueAtQuantile| { &m.value },
                |m: &mut ValueAtQuantile| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValueAtQuantile>(
                "SummaryDataPoint.ValueAtQuantile",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ValueAtQuantile {
        const NAME: &'static str = "ValueAtQuantile";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.quantile = is.read_double()?;
                    },
                    17 => {
                        self.value = is.read_double()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.quantile != 0. {
                my_size += 1 + 8;
            }
            if self.value != 0. {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.quantile != 0. {
                os.write_double(1, self.quantile)?;
            }
            if self.value != 0. {
                os.write_double(2, self.value)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ValueAtQuantile {
            ValueAtQuantile::new()
        }

        fn clear(&mut self) {
            self.quantile = 0.;
            self.value = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ValueAtQuantile {
            static instance: ValueAtQuantile = ValueAtQuantile {
                quantile: 0.,
                value: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ValueAtQuantile {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SummaryDataPoint.ValueAtQuantile").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ValueAtQuantile {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ValueAtQuantile {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  A representation of an exemplar, which is a sample input measurement.
///  Exemplars also hold information about the environment when the measurement
///  was recorded, for example the span and trace ID of the active span when the
///  exemplar was recorded.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.Exemplar)
pub struct Exemplar {
    // message fields
    ///  The set of key/value pairs that were filtered out by the aggregator, but
    ///  recorded alongside the original measurement. Only key/value pairs that were
    ///  filtered out by the aggregator should be included
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.Exemplar.filtered_attributes)
    pub filtered_attributes: ::std::vec::Vec<KeyValue>,
    ///  time_unix_nano is the exact time when this exemplar was recorded
    ///
    ///  Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    ///  1970.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.Exemplar.time_unix_nano)
    pub time_unix_nano: u64,
    ///  (Optional) Span ID of the exemplar trace.
    ///  span_id may be missing if the measurement is not recorded inside a trace
    ///  or if the trace is not sampled.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.Exemplar.span_id)
    pub span_id: ::std::vec::Vec<u8>,
    ///  (Optional) Trace ID of the exemplar trace.
    ///  trace_id may be missing if the measurement is not recorded inside a trace
    ///  or if the trace is not sampled.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.Exemplar.trace_id)
    pub trace_id: ::std::vec::Vec<u8>,
    // message oneof groups
    pub value: ::std::option::Option<exemplar::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.Exemplar.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Exemplar {
    fn default() -> &'a Exemplar {
        <Exemplar as ::protobuf::Message>::default_instance()
    }
}

impl Exemplar {
    pub fn new() -> Exemplar {
        ::std::default::Default::default()
    }

    // double as_double = 3;

    pub fn as_double(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(exemplar::Value::AsDouble(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_as_double(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_as_double(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(exemplar::Value::AsDouble(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_as_double(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(exemplar::Value::AsDouble(v))
    }

    // sfixed64 as_int = 6;

    pub fn as_int(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(exemplar::Value::AsInt(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_as_int(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_as_int(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(exemplar::Value::AsInt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_as_int(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(exemplar::Value::AsInt(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "filtered_attributes",
            |m: &Exemplar| { &m.filtered_attributes },
            |m: &mut Exemplar| { &mut m.filtered_attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time_unix_nano",
            |m: &Exemplar| { &m.time_unix_nano },
            |m: &mut Exemplar| { &mut m.time_unix_nano },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "as_double",
            Exemplar::has_as_double,
            Exemplar::as_double,
            Exemplar::set_as_double,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "as_int",
            Exemplar::has_as_int,
            Exemplar::as_int,
            Exemplar::set_as_int,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "span_id",
            |m: &Exemplar| { &m.span_id },
            |m: &mut Exemplar| { &mut m.span_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "trace_id",
            |m: &Exemplar| { &m.trace_id },
            |m: &mut Exemplar| { &mut m.trace_id },
        ));
        oneofs.push(exemplar::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Exemplar>(
            "Exemplar",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Exemplar {
    const NAME: &'static str = "Exemplar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                58 => {
                    self.filtered_attributes.push(is.read_message()?);
                },
                17 => {
                    self.time_unix_nano = is.read_fixed64()?;
                },
                25 => {
                    self.value = ::std::option::Option::Some(exemplar::Value::AsDouble(is.read_double()?));
                },
                49 => {
                    self.value = ::std::option::Option::Some(exemplar::Value::AsInt(is.read_sfixed64()?));
                },
                34 => {
                    self.span_id = is.read_bytes()?;
                },
                42 => {
                    self.trace_id = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.filtered_attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.time_unix_nano != 0 {
            my_size += 1 + 8;
        }
        if !self.span_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.span_id);
        }
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.trace_id);
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &exemplar::Value::AsDouble(v) => {
                    my_size += 1 + 8;
                },
                &exemplar::Value::AsInt(v) => {
                    my_size += 1 + 8;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.filtered_attributes {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if self.time_unix_nano != 0 {
            os.write_fixed64(2, self.time_unix_nano)?;
        }
        if !self.span_id.is_empty() {
            os.write_bytes(4, &self.span_id)?;
        }
        if !self.trace_id.is_empty() {
            os.write_bytes(5, &self.trace_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &exemplar::Value::AsDouble(v) => {
                    os.write_double(3, v)?;
                },
                &exemplar::Value::AsInt(v) => {
                    os.write_sfixed64(6, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Exemplar {
        Exemplar::new()
    }

    fn clear(&mut self) {
        self.filtered_attributes.clear();
        self.time_unix_nano = 0;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.span_id.clear();
        self.trace_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Exemplar {
        static instance: Exemplar = Exemplar {
            filtered_attributes: ::std::vec::Vec::new(),
            time_unix_nano: 0,
            span_id: ::std::vec::Vec::new(),
            trace_id: ::std::vec::Vec::new(),
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Exemplar {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Exemplar").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Exemplar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Exemplar {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Exemplar`
pub mod exemplar {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:opentelemetry.proto.collector.metrics.v1.Exemplar.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:opentelemetry.proto.collector.metrics.v1.Exemplar.as_double)
        AsDouble(f64),
        // @@protoc_insertion_point(oneof_field:opentelemetry.proto.collector.metrics.v1.Exemplar.as_int)
        AsInt(i64),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Exemplar as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
}

///  AnyValue is used to represent any type of attribute value. AnyValue may contain a
///  primitive value such as a string or integer or it may contain an arbitrary nested
///  object containing arrays, key-value lists and primitives.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.AnyValue)
pub struct AnyValue {
    // message oneof groups
    pub value: ::std::option::Option<any_value::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.AnyValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AnyValue {
    fn default() -> &'a AnyValue {
        <AnyValue as ::protobuf::Message>::default_instance()
    }
}

impl AnyValue {
    pub fn new() -> AnyValue {
        ::std::default::Default::default()
    }

    // string string_value = 1;

    pub fn string_value(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(any_value::Value::StringValue(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_string_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(any_value::Value::StringValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(any_value::Value::StringValue(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(any_value::Value::StringValue(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(any_value::Value::StringValue(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(any_value::Value::StringValue(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        if self.has_string_value() {
            match self.value.take() {
                ::std::option::Option::Some(any_value::Value::StringValue(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bool bool_value = 2;

    pub fn bool_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(any_value::Value::BoolValue(v)) => v,
            _ => false,
        }
    }

    pub fn clear_bool_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_bool_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(any_value::Value::BoolValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool_value(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(any_value::Value::BoolValue(v))
    }

    // int64 int_value = 3;

    pub fn int_value(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(any_value::Value::IntValue(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_int_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(any_value::Value::IntValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(any_value::Value::IntValue(v))
    }

    // double double_value = 4;

    pub fn double_value(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(any_value::Value::DoubleValue(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear_double_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(any_value::Value::DoubleValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(any_value::Value::DoubleValue(v))
    }

    // .opentelemetry.proto.collector.metrics.v1.ArrayValue array_value = 5;

    pub fn array_value(&self) -> &ArrayValue {
        match self.value {
            ::std::option::Option::Some(any_value::Value::ArrayValue(ref v)) => v,
            _ => <ArrayValue as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_array_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_array_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(any_value::Value::ArrayValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_array_value(&mut self, v: ArrayValue) {
        self.value = ::std::option::Option::Some(any_value::Value::ArrayValue(v))
    }

    // Mutable pointer to the field.
    pub fn mut_array_value(&mut self) -> &mut ArrayValue {
        if let ::std::option::Option::Some(any_value::Value::ArrayValue(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(any_value::Value::ArrayValue(ArrayValue::new()));
        }
        match self.value {
            ::std::option::Option::Some(any_value::Value::ArrayValue(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_array_value(&mut self) -> ArrayValue {
        if self.has_array_value() {
            match self.value.take() {
                ::std::option::Option::Some(any_value::Value::ArrayValue(v)) => v,
                _ => panic!(),
            }
        } else {
            ArrayValue::new()
        }
    }

    // .opentelemetry.proto.collector.metrics.v1.KeyValueList kvlist_value = 6;

    pub fn kvlist_value(&self) -> &KeyValueList {
        match self.value {
            ::std::option::Option::Some(any_value::Value::KvlistValue(ref v)) => v,
            _ => <KeyValueList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_kvlist_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_kvlist_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(any_value::Value::KvlistValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_kvlist_value(&mut self, v: KeyValueList) {
        self.value = ::std::option::Option::Some(any_value::Value::KvlistValue(v))
    }

    // Mutable pointer to the field.
    pub fn mut_kvlist_value(&mut self) -> &mut KeyValueList {
        if let ::std::option::Option::Some(any_value::Value::KvlistValue(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(any_value::Value::KvlistValue(KeyValueList::new()));
        }
        match self.value {
            ::std::option::Option::Some(any_value::Value::KvlistValue(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_kvlist_value(&mut self) -> KeyValueList {
        if self.has_kvlist_value() {
            match self.value.take() {
                ::std::option::Option::Some(any_value::Value::KvlistValue(v)) => v,
                _ => panic!(),
            }
        } else {
            KeyValueList::new()
        }
    }

    // bytes bytes_value = 7;

    pub fn bytes_value(&self) -> &[u8] {
        match self.value {
            ::std::option::Option::Some(any_value::Value::BytesValue(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_bytes_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_bytes_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(any_value::Value::BytesValue(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bytes_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = ::std::option::Option::Some(any_value::Value::BytesValue(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bytes_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(any_value::Value::BytesValue(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(any_value::Value::BytesValue(::std::vec::Vec::new()));
        }
        match self.value {
            ::std::option::Option::Some(any_value::Value::BytesValue(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bytes_value(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_bytes_value() {
            match self.value.take() {
                ::std::option::Option::Some(any_value::Value::BytesValue(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "string_value",
            AnyValue::has_string_value,
            AnyValue::string_value,
            AnyValue::set_string_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "bool_value",
            AnyValue::has_bool_value,
            AnyValue::bool_value,
            AnyValue::set_bool_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "int_value",
            AnyValue::has_int_value,
            AnyValue::int_value,
            AnyValue::set_int_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "double_value",
            AnyValue::has_double_value,
            AnyValue::double_value,
            AnyValue::set_double_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ArrayValue>(
            "array_value",
            AnyValue::has_array_value,
            AnyValue::array_value,
            AnyValue::mut_array_value,
            AnyValue::set_array_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, KeyValueList>(
            "kvlist_value",
            AnyValue::has_kvlist_value,
            AnyValue::kvlist_value,
            AnyValue::mut_kvlist_value,
            AnyValue::set_kvlist_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "bytes_value",
            AnyValue::has_bytes_value,
            AnyValue::bytes_value,
            AnyValue::set_bytes_value,
        ));
        oneofs.push(any_value::Value::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnyValue>(
            "AnyValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AnyValue {
    const NAME: &'static str = "AnyValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = ::std::option::Option::Some(any_value::Value::StringValue(is.read_string()?));
                },
                16 => {
                    self.value = ::std::option::Option::Some(any_value::Value::BoolValue(is.read_bool()?));
                },
                24 => {
                    self.value = ::std::option::Option::Some(any_value::Value::IntValue(is.read_int64()?));
                },
                33 => {
                    self.value = ::std::option::Option::Some(any_value::Value::DoubleValue(is.read_double()?));
                },
                42 => {
                    self.value = ::std::option::Option::Some(any_value::Value::ArrayValue(is.read_message()?));
                },
                50 => {
                    self.value = ::std::option::Option::Some(any_value::Value::KvlistValue(is.read_message()?));
                },
                58 => {
                    self.value = ::std::option::Option::Some(any_value::Value::BytesValue(is.read_bytes()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &any_value::Value::StringValue(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &any_value::Value::BoolValue(v) => {
                    my_size += 1 + 1;
                },
                &any_value::Value::IntValue(v) => {
                    my_size += ::protobuf::rt::int64_size(3, v);
                },
                &any_value::Value::DoubleValue(v) => {
                    my_size += 1 + 8;
                },
                &any_value::Value::ArrayValue(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &any_value::Value::KvlistValue(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &any_value::Value::BytesValue(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(7, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &any_value::Value::StringValue(ref v) => {
                    os.write_string(1, v)?;
                },
                &any_value::Value::BoolValue(v) => {
                    os.write_bool(2, v)?;
                },
                &any_value::Value::IntValue(v) => {
                    os.write_int64(3, v)?;
                },
                &any_value::Value::DoubleValue(v) => {
                    os.write_double(4, v)?;
                },
                &any_value::Value::ArrayValue(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &any_value::Value::KvlistValue(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &any_value::Value::BytesValue(ref v) => {
                    os.write_bytes(7, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AnyValue {
        AnyValue::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AnyValue {
        static instance: AnyValue = AnyValue {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AnyValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AnyValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AnyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnyValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AnyValue`
pub mod any_value {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:opentelemetry.proto.collector.metrics.v1.AnyValue.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:opentelemetry.proto.collector.metrics.v1.AnyValue.string_value)
        StringValue(::std::string::String),
        // @@protoc_insertion_point(oneof_field:opentelemetry.proto.collector.metrics.v1.AnyValue.bool_value)
        BoolValue(bool),
        // @@protoc_insertion_point(oneof_field:opentelemetry.proto.collector.metrics.v1.AnyValue.int_value)
        IntValue(i64),
        // @@protoc_insertion_point(oneof_field:opentelemetry.proto.collector.metrics.v1.AnyValue.double_value)
        DoubleValue(f64),
        // @@protoc_insertion_point(oneof_field:opentelemetry.proto.collector.metrics.v1.AnyValue.array_value)
        ArrayValue(super::ArrayValue),
        // @@protoc_insertion_point(oneof_field:opentelemetry.proto.collector.metrics.v1.AnyValue.kvlist_value)
        KvlistValue(super::KeyValueList),
        // @@protoc_insertion_point(oneof_field:opentelemetry.proto.collector.metrics.v1.AnyValue.bytes_value)
        BytesValue(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl ::protobuf::OneofFull for Value {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::AnyValue as ::protobuf::MessageFull>::descriptor().oneof_by_name("value").unwrap()).clone()
        }
    }

    impl Value {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value>("value")
        }
    }
}

///  ArrayValue is a list of AnyValue messages. We need ArrayValue as a message
///  since oneof in AnyValue does not allow repeated fields.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.ArrayValue)
pub struct ArrayValue {
    // message fields
    ///  Array of values. The array may be empty (contain 0 elements).
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.ArrayValue.values)
    pub values: ::std::vec::Vec<AnyValue>,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.ArrayValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ArrayValue {
    fn default() -> &'a ArrayValue {
        <ArrayValue as ::protobuf::Message>::default_instance()
    }
}

impl ArrayValue {
    pub fn new() -> ArrayValue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &ArrayValue| { &m.values },
            |m: &mut ArrayValue| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArrayValue>(
            "ArrayValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ArrayValue {
    const NAME: &'static str = "ArrayValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.values.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.values {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ArrayValue {
        ArrayValue::new()
    }

    fn clear(&mut self) {
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ArrayValue {
        static instance: ArrayValue = ArrayValue {
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ArrayValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ArrayValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ArrayValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArrayValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  KeyValueList is a list of KeyValue messages. We need KeyValueList as a message
///  since `oneof` in AnyValue does not allow repeated fields. Everywhere else where we need
///  a list of KeyValue messages (e.g. in Span) we use `repeated KeyValue` directly to
///  avoid unnecessary extra wrapping (which slows down the protocol). The 2 approaches
///  are semantically equivalent.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.KeyValueList)
pub struct KeyValueList {
    // message fields
    ///  A collection of key/value pairs of key-value pairs. The list may be empty (may
    ///  contain 0 elements).
    ///  The keys MUST be unique (it is not allowed to have more than one
    ///  value with the same key).
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.KeyValueList.values)
    pub values: ::std::vec::Vec<KeyValue>,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.KeyValueList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyValueList {
    fn default() -> &'a KeyValueList {
        <KeyValueList as ::protobuf::Message>::default_instance()
    }
}

impl KeyValueList {
    pub fn new() -> KeyValueList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &KeyValueList| { &m.values },
            |m: &mut KeyValueList| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyValueList>(
            "KeyValueList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyValueList {
    const NAME: &'static str = "KeyValueList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.values.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.values {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyValueList {
        KeyValueList::new()
    }

    fn clear(&mut self) {
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyValueList {
        static instance: KeyValueList = KeyValueList {
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyValueList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyValueList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyValueList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyValueList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  KeyValue is a key-value pair that is used to store Span attributes, Link
///  attributes, etc.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.KeyValue)
pub struct KeyValue {
    // message fields
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.KeyValue.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.KeyValue.value)
    pub value: ::protobuf::MessageField<AnyValue>,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.KeyValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeyValue {
    fn default() -> &'a KeyValue {
        <KeyValue as ::protobuf::Message>::default_instance()
    }
}

impl KeyValue {
    pub fn new() -> KeyValue {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &KeyValue| { &m.key },
            |m: &mut KeyValue| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AnyValue>(
            "value",
            |m: &KeyValue| { &m.value },
            |m: &mut KeyValue| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeyValue>(
            "KeyValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeyValue {
    const NAME: &'static str = "KeyValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeyValue {
        KeyValue::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeyValue {
        static instance: KeyValue = KeyValue {
            key: ::std::string::String::new(),
            value: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeyValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeyValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  InstrumentationScope is a message representing the instrumentation scope information
///  such as the fully qualified name and version.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.InstrumentationScope)
pub struct InstrumentationScope {
    // message fields
    ///  An empty instrumentation scope name means the name is unknown.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.InstrumentationScope.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.InstrumentationScope.version)
    pub version: ::std::string::String,
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.InstrumentationScope.attributes)
    pub attributes: ::std::vec::Vec<KeyValue>,
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.InstrumentationScope.dropped_attributes_count)
    pub dropped_attributes_count: u32,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.InstrumentationScope.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstrumentationScope {
    fn default() -> &'a InstrumentationScope {
        <InstrumentationScope as ::protobuf::Message>::default_instance()
    }
}

impl InstrumentationScope {
    pub fn new() -> InstrumentationScope {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &InstrumentationScope| { &m.name },
            |m: &mut InstrumentationScope| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &InstrumentationScope| { &m.version },
            |m: &mut InstrumentationScope| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attributes",
            |m: &InstrumentationScope| { &m.attributes },
            |m: &mut InstrumentationScope| { &mut m.attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dropped_attributes_count",
            |m: &InstrumentationScope| { &m.dropped_attributes_count },
            |m: &mut InstrumentationScope| { &mut m.dropped_attributes_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InstrumentationScope>(
            "InstrumentationScope",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InstrumentationScope {
    const NAME: &'static str = "InstrumentationScope";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.version = is.read_string()?;
                },
                26 => {
                    self.attributes.push(is.read_message()?);
                },
                32 => {
                    self.dropped_attributes_count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.dropped_attributes_count != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.dropped_attributes_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        for v in &self.attributes {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if self.dropped_attributes_count != 0 {
            os.write_uint32(4, self.dropped_attributes_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstrumentationScope {
        InstrumentationScope::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.version.clear();
        self.attributes.clear();
        self.dropped_attributes_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstrumentationScope {
        static instance: InstrumentationScope = InstrumentationScope {
            name: ::std::string::String::new(),
            version: ::std::string::String::new(),
            attributes: ::std::vec::Vec::new(),
            dropped_attributes_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InstrumentationScope {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InstrumentationScope").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InstrumentationScope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstrumentationScope {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Resource information.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:opentelemetry.proto.collector.metrics.v1.Resource)
pub struct Resource {
    // message fields
    ///  Set of attributes that describe the resource.
    ///  Attribute keys MUST be unique (it is not allowed to have more than one
    ///  attribute with the same key).
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.Resource.attributes)
    pub attributes: ::std::vec::Vec<KeyValue>,
    ///  dropped_attributes_count is the number of dropped attributes. If the value is 0, then
    ///  no attributes were dropped.
    // @@protoc_insertion_point(field:opentelemetry.proto.collector.metrics.v1.Resource.dropped_attributes_count)
    pub dropped_attributes_count: u32,
    // special fields
    // @@protoc_insertion_point(special_field:opentelemetry.proto.collector.metrics.v1.Resource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Resource {
    fn default() -> &'a Resource {
        <Resource as ::protobuf::Message>::default_instance()
    }
}

impl Resource {
    pub fn new() -> Resource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attributes",
            |m: &Resource| { &m.attributes },
            |m: &mut Resource| { &mut m.attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dropped_attributes_count",
            |m: &Resource| { &m.dropped_attributes_count },
            |m: &mut Resource| { &mut m.dropped_attributes_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Resource>(
            "Resource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Resource {
    const NAME: &'static str = "Resource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.attributes.push(is.read_message()?);
                },
                16 => {
                    self.dropped_attributes_count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.dropped_attributes_count != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.dropped_attributes_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.attributes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.dropped_attributes_count != 0 {
            os.write_uint32(2, self.dropped_attributes_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Resource {
        Resource::new()
    }

    fn clear(&mut self) {
        self.attributes.clear();
        self.dropped_attributes_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Resource {
        static instance: Resource = Resource {
            attributes: ::std::vec::Vec::new(),
            dropped_attributes_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Resource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Resource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Resource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Resource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  AggregationTemporality defines how a metric aggregator reports aggregated
///  values. It describes how those values relate to the time interval over
///  which they are aggregated.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:opentelemetry.proto.collector.metrics.v1.AggregationTemporality)
pub enum AggregationTemporality {
    // @@protoc_insertion_point(enum_value:opentelemetry.proto.collector.metrics.v1.AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED)
    AGGREGATION_TEMPORALITY_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:opentelemetry.proto.collector.metrics.v1.AggregationTemporality.AGGREGATION_TEMPORALITY_DELTA)
    AGGREGATION_TEMPORALITY_DELTA = 1,
    // @@protoc_insertion_point(enum_value:opentelemetry.proto.collector.metrics.v1.AggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE)
    AGGREGATION_TEMPORALITY_CUMULATIVE = 2,
}

impl ::protobuf::Enum for AggregationTemporality {
    const NAME: &'static str = "AggregationTemporality";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AggregationTemporality> {
        match value {
            0 => ::std::option::Option::Some(AggregationTemporality::AGGREGATION_TEMPORALITY_UNSPECIFIED),
            1 => ::std::option::Option::Some(AggregationTemporality::AGGREGATION_TEMPORALITY_DELTA),
            2 => ::std::option::Option::Some(AggregationTemporality::AGGREGATION_TEMPORALITY_CUMULATIVE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AggregationTemporality] = &[
        AggregationTemporality::AGGREGATION_TEMPORALITY_UNSPECIFIED,
        AggregationTemporality::AGGREGATION_TEMPORALITY_DELTA,
        AggregationTemporality::AGGREGATION_TEMPORALITY_CUMULATIVE,
    ];
}

impl ::protobuf::EnumFull for AggregationTemporality {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AggregationTemporality").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AggregationTemporality {
    fn default() -> Self {
        AggregationTemporality::AGGREGATION_TEMPORALITY_UNSPECIFIED
    }
}

impl AggregationTemporality {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AggregationTemporality>("AggregationTemporality")
    }
}

///  DataPointFlags is defined as a protobuf 'uint32' type and is to be used as a
///  bit-field representing 32 distinct boolean flags.  Each flag defined in this
///  enum is a bit-mask.  To test the presence of a single flag in the flags of
///  a data point, for example, use an expression like:
///
///    (point.flags & FLAG_NO_RECORDED_VALUE) == FLAG_NO_RECORDED_VALUE
///
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:opentelemetry.proto.collector.metrics.v1.DataPointFlags)
pub enum DataPointFlags {
    // @@protoc_insertion_point(enum_value:opentelemetry.proto.collector.metrics.v1.DataPointFlags.FLAG_NONE)
    FLAG_NONE = 0,
    // @@protoc_insertion_point(enum_value:opentelemetry.proto.collector.metrics.v1.DataPointFlags.FLAG_NO_RECORDED_VALUE)
    FLAG_NO_RECORDED_VALUE = 1,
}

impl ::protobuf::Enum for DataPointFlags {
    const NAME: &'static str = "DataPointFlags";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataPointFlags> {
        match value {
            0 => ::std::option::Option::Some(DataPointFlags::FLAG_NONE),
            1 => ::std::option::Option::Some(DataPointFlags::FLAG_NO_RECORDED_VALUE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DataPointFlags] = &[
        DataPointFlags::FLAG_NONE,
        DataPointFlags::FLAG_NO_RECORDED_VALUE,
    ];
}

impl ::protobuf::EnumFull for DataPointFlags {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DataPointFlags").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DataPointFlags {
    fn default() -> Self {
        DataPointFlags::FLAG_NONE
    }
}

impl DataPointFlags {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DataPointFlags>("DataPointFlags")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15metrics_service.proto\x12(opentelemetry.proto.collector.metrics.v1\
    \"\x83\x01\n\x1bExportMetricsServiceRequest\x12d\n\x10resource_metrics\
    \x18\x01\x20\x03(\x0b29.opentelemetry.proto.collector.metrics.v1.Resourc\
    eMetricsR\x0fresourceMetrics\"\x1e\n\x1cExportMetricsServiceResponse\"s\
    \n\x0bMetricsData\x12d\n\x10resource_metrics\x18\x01\x20\x03(\x0b29.open\
    telemetry.proto.collector.metrics.v1.ResourceMetricsR\x0fresourceMetrics\
    \"\xe5\x01\n\x0fResourceMetrics\x12N\n\x08resource\x18\x01\x20\x01(\x0b2\
    2.opentelemetry.proto.collector.metrics.v1.ResourceR\x08resource\x12[\n\
    \rscope_metrics\x18\x02\x20\x03(\x0b26.opentelemetry.proto.collector.met\
    rics.v1.ScopeMetricsR\x0cscopeMetrics\x12\x1d\n\nschema_url\x18\x03\x20\
    \x01(\tR\tschemaUrlJ\x06\x08\xe8\x07\x10\xe9\x07\"\xcf\x01\n\x0cScopeMet\
    rics\x12T\n\x05scope\x18\x01\x20\x01(\x0b2>.opentelemetry.proto.collecto\
    r.metrics.v1.InstrumentationScopeR\x05scope\x12J\n\x07metrics\x18\x02\
    \x20\x03(\x0b20.opentelemetry.proto.collector.metrics.v1.MetricR\x07metr\
    ics\x12\x1d\n\nschema_url\x18\x03\x20\x01(\tR\tschemaUrl\"\x93\x04\n\x06\
    Metric\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x20\n\x0bdescri\
    ption\x18\x02\x20\x01(\tR\x0bdescription\x12\x12\n\x04unit\x18\x03\x20\
    \x01(\tR\x04unit\x12G\n\x05gauge\x18\x05\x20\x01(\x0b2/.opentelemetry.pr\
    oto.collector.metrics.v1.GaugeH\0R\x05gauge\x12A\n\x03sum\x18\x07\x20\
    \x01(\x0b2-.opentelemetry.proto.collector.metrics.v1.SumH\0R\x03sum\x12S\
    \n\thistogram\x18\t\x20\x01(\x0b23.opentelemetry.proto.collector.metrics\
    .v1.HistogramH\0R\thistogram\x12u\n\x15exponential_histogram\x18\n\x20\
    \x01(\x0b2>.opentelemetry.proto.collector.metrics.v1.ExponentialHistogra\
    mH\0R\x14exponentialHistogram\x12M\n\x07summary\x18\x0b\x20\x01(\x0b21.o\
    pentelemetry.proto.collector.metrics.v1.SummaryH\0R\x07summaryB\x06\n\
    \x04dataJ\x04\x08\x04\x10\x05J\x04\x08\x06\x10\x07J\x04\x08\x08\x10\t\"c\
    \n\x05Gauge\x12Z\n\x0bdata_points\x18\x01\x20\x03(\x0b29.opentelemetry.p\
    roto.collector.metrics.v1.NumberDataPointR\ndataPoints\"\xff\x01\n\x03Su\
    m\x12Z\n\x0bdata_points\x18\x01\x20\x03(\x0b29.opentelemetry.proto.colle\
    ctor.metrics.v1.NumberDataPointR\ndataPoints\x12y\n\x17aggregation_tempo\
    rality\x18\x02\x20\x01(\x0e2@.opentelemetry.proto.collector.metrics.v1.A\
    ggregationTemporalityR\x16aggregationTemporality\x12!\n\x0cis_monotonic\
    \x18\x03\x20\x01(\x08R\x0bisMonotonic\"\xe5\x01\n\tHistogram\x12]\n\x0bd\
    ata_points\x18\x01\x20\x03(\x0b2<.opentelemetry.proto.collector.metrics.\
    v1.HistogramDataPointR\ndataPoints\x12y\n\x17aggregation_temporality\x18\
    \x02\x20\x01(\x0e2@.opentelemetry.proto.collector.metrics.v1.Aggregation\
    TemporalityR\x16aggregationTemporality\"\xfb\x01\n\x14ExponentialHistogr\
    am\x12h\n\x0bdata_points\x18\x01\x20\x03(\x0b2G.opentelemetry.proto.coll\
    ector.metrics.v1.ExponentialHistogramDataPointR\ndataPoints\x12y\n\x17ag\
    gregation_temporality\x18\x02\x20\x01(\x0e2@.opentelemetry.proto.collect\
    or.metrics.v1.AggregationTemporalityR\x16aggregationTemporality\"f\n\x07\
    Summary\x12[\n\x0bdata_points\x18\x01\x20\x03(\x0b2:.opentelemetry.proto\
    .collector.metrics.v1.SummaryDataPointR\ndataPoints\"\xeb\x02\n\x0fNumbe\
    rDataPoint\x12R\n\nattributes\x18\x07\x20\x03(\x0b22.opentelemetry.proto\
    .collector.metrics.v1.KeyValueR\nattributes\x12/\n\x14start_time_unix_na\
    no\x18\x02\x20\x01(\x06R\x11startTimeUnixNano\x12$\n\x0etime_unix_nano\
    \x18\x03\x20\x01(\x06R\x0ctimeUnixNano\x12\x1d\n\tas_double\x18\x04\x20\
    \x01(\x01H\0R\x08asDouble\x12\x17\n\x06as_int\x18\x06\x20\x01(\x10H\0R\
    \x05asInt\x12P\n\texemplars\x18\x05\x20\x03(\x0b22.opentelemetry.proto.c\
    ollector.metrics.v1.ExemplarR\texemplars\x12\x14\n\x05flags\x18\x08\x20\
    \x01(\rR\x05flagsB\x07\n\x05valueJ\x04\x08\x01\x10\x02\"\xee\x03\n\x12Hi\
    stogramDataPoint\x12R\n\nattributes\x18\t\x20\x03(\x0b22.opentelemetry.p\
    roto.collector.metrics.v1.KeyValueR\nattributes\x12/\n\x14start_time_uni\
    x_nano\x18\x02\x20\x01(\x06R\x11startTimeUnixNano\x12$\n\x0etime_unix_na\
    no\x18\x03\x20\x01(\x06R\x0ctimeUnixNano\x12\x14\n\x05count\x18\x04\x20\
    \x01(\x06R\x05count\x12\x15\n\x03sum\x18\x05\x20\x01(\x01H\0R\x03sum\x88\
    \x01\x01\x12#\n\rbucket_counts\x18\x06\x20\x03(\x06R\x0cbucketCounts\x12\
    '\n\x0fexplicit_bounds\x18\x07\x20\x03(\x01R\x0eexplicitBounds\x12P\n\te\
    xemplars\x18\x08\x20\x03(\x0b22.opentelemetry.proto.collector.metrics.v1\
    .ExemplarR\texemplars\x12\x14\n\x05flags\x18\n\x20\x01(\rR\x05flags\x12\
    \x15\n\x03min\x18\x0b\x20\x01(\x01H\x01R\x03min\x88\x01\x01\x12\x15\n\
    \x03max\x18\x0c\x20\x01(\x01H\x02R\x03max\x88\x01\x01B\x06\n\x04_sumB\
    \x06\n\x04_minB\x06\n\x04_maxJ\x04\x08\x01\x10\x02\"\xfc\x05\n\x1dExpone\
    ntialHistogramDataPoint\x12R\n\nattributes\x18\x01\x20\x03(\x0b22.opente\
    lemetry.proto.collector.metrics.v1.KeyValueR\nattributes\x12/\n\x14start\
    _time_unix_nano\x18\x02\x20\x01(\x06R\x11startTimeUnixNano\x12$\n\x0etim\
    e_unix_nano\x18\x03\x20\x01(\x06R\x0ctimeUnixNano\x12\x14\n\x05count\x18\
    \x04\x20\x01(\x06R\x05count\x12\x15\n\x03sum\x18\x05\x20\x01(\x01H\0R\
    \x03sum\x88\x01\x01\x12\x14\n\x05scale\x18\x06\x20\x01(\x11R\x05scale\
    \x12\x1d\n\nzero_count\x18\x07\x20\x01(\x06R\tzeroCount\x12k\n\x08positi\
    ve\x18\x08\x20\x01(\x0b2O.opentelemetry.proto.collector.metrics.v1.Expon\
    entialHistogramDataPoint.BucketsR\x08positive\x12k\n\x08negative\x18\t\
    \x20\x01(\x0b2O.opentelemetry.proto.collector.metrics.v1.ExponentialHist\
    ogramDataPoint.BucketsR\x08negative\x12\x14\n\x05flags\x18\n\x20\x01(\rR\
    \x05flags\x12P\n\texemplars\x18\x0b\x20\x03(\x0b22.opentelemetry.proto.c\
    ollector.metrics.v1.ExemplarR\texemplars\x12\x15\n\x03min\x18\x0c\x20\
    \x01(\x01H\x01R\x03min\x88\x01\x01\x12\x15\n\x03max\x18\r\x20\x01(\x01H\
    \x02R\x03max\x88\x01\x01\x1aF\n\x07Buckets\x12\x16\n\x06offset\x18\x01\
    \x20\x01(\x11R\x06offset\x12#\n\rbucket_counts\x18\x02\x20\x03(\x04R\x0c\
    bucketCountsB\x06\n\x04_sumB\x06\n\x04_minB\x06\n\x04_max\"\xbb\x03\n\
    \x10SummaryDataPoint\x12R\n\nattributes\x18\x07\x20\x03(\x0b22.opentelem\
    etry.proto.collector.metrics.v1.KeyValueR\nattributes\x12/\n\x14start_ti\
    me_unix_nano\x18\x02\x20\x01(\x06R\x11startTimeUnixNano\x12$\n\x0etime_u\
    nix_nano\x18\x03\x20\x01(\x06R\x0ctimeUnixNano\x12\x14\n\x05count\x18\
    \x04\x20\x01(\x06R\x05count\x12\x10\n\x03sum\x18\x05\x20\x01(\x01R\x03su\
    m\x12s\n\x0fquantile_values\x18\x06\x20\x03(\x0b2J.opentelemetry.proto.c\
    ollector.metrics.v1.SummaryDataPoint.ValueAtQuantileR\x0equantileValues\
    \x12\x14\n\x05flags\x18\x08\x20\x01(\rR\x05flags\x1aC\n\x0fValueAtQuanti\
    le\x12\x1a\n\x08quantile\x18\x01\x20\x01(\x01R\x08quantile\x12\x14\n\x05\
    value\x18\x02\x20\x01(\x01R\x05valueJ\x04\x08\x01\x10\x02\"\x90\x02\n\
    \x08Exemplar\x12c\n\x13filtered_attributes\x18\x07\x20\x03(\x0b22.opente\
    lemetry.proto.collector.metrics.v1.KeyValueR\x12filteredAttributes\x12$\
    \n\x0etime_unix_nano\x18\x02\x20\x01(\x06R\x0ctimeUnixNano\x12\x1d\n\tas\
    _double\x18\x03\x20\x01(\x01H\0R\x08asDouble\x12\x17\n\x06as_int\x18\x06\
    \x20\x01(\x10H\0R\x05asInt\x12\x17\n\x07span_id\x18\x04\x20\x01(\x0cR\
    \x06spanId\x12\x19\n\x08trace_id\x18\x05\x20\x01(\x0cR\x07traceIdB\x07\n\
    \x05valueJ\x04\x08\x01\x10\x02\"\xf6\x02\n\x08AnyValue\x12#\n\x0cstring_\
    value\x18\x01\x20\x01(\tH\0R\x0bstringValue\x12\x1f\n\nbool_value\x18\
    \x02\x20\x01(\x08H\0R\tboolValue\x12\x1d\n\tint_value\x18\x03\x20\x01(\
    \x03H\0R\x08intValue\x12#\n\x0cdouble_value\x18\x04\x20\x01(\x01H\0R\x0b\
    doubleValue\x12W\n\x0barray_value\x18\x05\x20\x01(\x0b24.opentelemetry.p\
    roto.collector.metrics.v1.ArrayValueH\0R\narrayValue\x12[\n\x0ckvlist_va\
    lue\x18\x06\x20\x01(\x0b26.opentelemetry.proto.collector.metrics.v1.KeyV\
    alueListH\0R\x0bkvlistValue\x12!\n\x0bbytes_value\x18\x07\x20\x01(\x0cH\
    \0R\nbytesValueB\x07\n\x05value\"X\n\nArrayValue\x12J\n\x06values\x18\
    \x01\x20\x03(\x0b22.opentelemetry.proto.collector.metrics.v1.AnyValueR\
    \x06values\"Z\n\x0cKeyValueList\x12J\n\x06values\x18\x01\x20\x03(\x0b22.\
    opentelemetry.proto.collector.metrics.v1.KeyValueR\x06values\"f\n\x08Key\
    Value\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12H\n\x05value\x18\
    \x02\x20\x01(\x0b22.opentelemetry.proto.collector.metrics.v1.AnyValueR\
    \x05value\"\xd2\x01\n\x14InstrumentationScope\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12\x18\n\x07version\x18\x02\x20\x01(\tR\x07version\
    \x12R\n\nattributes\x18\x03\x20\x03(\x0b22.opentelemetry.proto.collector\
    .metrics.v1.KeyValueR\nattributes\x128\n\x18dropped_attributes_count\x18\
    \x04\x20\x01(\rR\x16droppedAttributesCount\"\x98\x01\n\x08Resource\x12R\
    \n\nattributes\x18\x01\x20\x03(\x0b22.opentelemetry.proto.collector.metr\
    ics.v1.KeyValueR\nattributes\x128\n\x18dropped_attributes_count\x18\x02\
    \x20\x01(\rR\x16droppedAttributesCount*\x8c\x01\n\x16AggregationTemporal\
    ity\x12'\n#AGGREGATION_TEMPORALITY_UNSPECIFIED\x10\0\x12!\n\x1dAGGREGATI\
    ON_TEMPORALITY_DELTA\x10\x01\x12&\n\"AGGREGATION_TEMPORALITY_CUMULATIVE\
    \x10\x02*;\n\x0eDataPointFlags\x12\r\n\tFLAG_NONE\x10\0\x12\x1a\n\x16FLA\
    G_NO_RECORDED_VALUE\x10\x012\xac\x01\n\x0eMetricsService\x12\x99\x01\n\
    \x06Export\x12E.opentelemetry.proto.collector.metrics.v1.ExportMetricsSe\
    rviceRequest\x1aF.opentelemetry.proto.collector.metrics.v1.ExportMetrics\
    ServiceResponse\"\0B\xa4\x01\n+io.opentelemetry.proto.collector.metrics.\
    v1B\x13MetricsServiceProtoP\x01Z3go.opentelemetry.io/proto/otlp/collecto\
    r/metrics/v1\xaa\x02(OpenTelemetry.Proto.Collector.Metrics.V1J\xbb\x81\
    \x02\n\x07\x12\x05\x0e\0\xee\x05\x01\n\xc8\x04\n\x01\x0c\x12\x03\x0e\0\
    \x122\xbd\x04\x20Copyright\x202019,\x20OpenTelemetry\x20Authors\n\n\x20L\
    icensed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\
    \x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20excep\
    t\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20obta\
    in\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20htt\
    p://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\
    \x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20softwar\
    e\n\x20distributed\x20under\x20the\x20License\x20is\x20distributed\x20on\
    \x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CON\
    DITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\
    \x20See\x20the\x20License\x20for\x20the\x20specific\x20language\x20gover\
    ning\x20permissions\x20and\n\x20limitations\x20under\x20the\x20License.\
    \n\n\x08\n\x01\x02\x12\x03\x10\01\n\x08\n\x01\x08\x12\x03\x12\0E\n\t\n\
    \x02\x08%\x12\x03\x12\0E\n\x08\n\x01\x08\x12\x03\x13\0\"\n\t\n\x02\x08\n\
    \x12\x03\x13\0\"\n\x08\n\x01\x08\x12\x03\x14\0D\n\t\n\x02\x08\x01\x12\
    \x03\x14\0D\n\x08\n\x01\x08\x12\x03\x15\04\n\t\n\x02\x08\x08\x12\x03\x15\
    \04\n\x08\n\x01\x08\x12\x03\x16\0J\n\t\n\x02\x08\x0b\x12\x03\x16\0J\n\
    \xb2\x01\n\x02\x06\0\x12\x04\x1b\0\x1f\x01\x1a\xa5\x01\x20Service\x20tha\
    t\x20can\x20be\x20used\x20to\x20push\x20metrics\x20between\x20one\x20App\
    lication\n\x20instrumented\x20with\x20OpenTelemetry\x20and\x20a\x20colle\
    ctor,\x20or\x20between\x20a\x20collector\x20and\x20a\n\x20central\x20col\
    lector.\n\n\n\n\x03\x06\0\x01\x12\x03\x1b\x08\x16\ny\n\x04\x06\0\x02\0\
    \x12\x03\x1e\x02S\x1al\x20For\x20performance\x20reasons,\x20it\x20is\x20\
    recommended\x20to\x20keep\x20this\x20RPC\n\x20alive\x20for\x20the\x20ent\
    ire\x20life\x20of\x20the\x20application.\n\n\x0c\n\x05\x06\0\x02\0\x01\
    \x12\x03\x1e\x06\x0c\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x1e\r(\n\x0c\n\
    \x05\x06\0\x02\0\x03\x12\x03\x1e3O\n\n\n\x02\x04\0\x12\x04!\0(\x01\n\n\n\
    \x03\x04\0\x01\x12\x03!\x08#\n\xd2\x02\n\x04\x04\0\x02\0\x12\x03'\x020\
    \x1a\xc4\x02\x20An\x20array\x20of\x20ResourceMetrics.\n\x20For\x20data\
    \x20coming\x20from\x20a\x20single\x20resource\x20this\x20array\x20will\
    \x20typically\x20contain\x20one\n\x20element.\x20Intermediary\x20nodes\
    \x20(such\x20as\x20OpenTelemetry\x20Collector)\x20that\x20receive\n\x20d\
    ata\x20from\x20multiple\x20origins\x20typically\x20batch\x20the\x20data\
    \x20before\x20forwarding\x20further\x20and\n\x20in\x20that\x20case\x20th\
    is\x20array\x20will\x20contain\x20multiple\x20elements.\n\n\x0c\n\x05\
    \x04\0\x02\0\x04\x12\x03'\x02\n\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03'\x0b\
    \x1a\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03'\x1b+\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03'./\n\n\n\x02\x04\x01\x12\x04*\0+\x01\n\n\n\x03\x04\x01\x01\
    \x12\x03*\x08$\n\xd1\x03\n\x02\x04\x02\x12\x047\0>\x01\x1a\xc4\x03\x20Me\
    tricsData\x20represents\x20the\x20metrics\x20data\x20that\x20can\x20be\
    \x20stored\x20in\x20a\x20persistent\n\x20storage,\x20OR\x20can\x20be\x20\
    embedded\x20by\x20other\x20protocols\x20that\x20transfer\x20OTLP\x20metr\
    ics\n\x20data\x20but\x20do\x20not\x20implement\x20the\x20OTLP\x20protoco\
    l.\n\n\x20The\x20main\x20difference\x20between\x20this\x20message\x20and\
    \x20collector\x20protocol\x20is\x20that\n\x20in\x20this\x20message\x20th\
    ere\x20will\x20not\x20be\x20any\x20\"control\"\x20or\x20\"metadata\"\x20\
    specific\x20to\n\x20OTLP\x20protocol.\n\n\x20When\x20new\x20fields\x20ar\
    e\x20added\x20into\x20this\x20message,\x20the\x20OTLP\x20request\x20MUST\
    \x20be\x20updated\n\x20as\x20well.\n\n\n\n\x03\x04\x02\x01\x12\x037\x08\
    \x13\n\xb0\x02\n\x04\x04\x02\x02\0\x12\x03=\x020\x1a\xa2\x02\x20An\x20ar\
    ray\x20of\x20ResourceMetrics.\n\x20For\x20data\x20coming\x20from\x20a\
    \x20single\x20resource\x20this\x20array\x20will\x20typically\x20contain\
    \n\x20one\x20element.\x20Intermediary\x20nodes\x20that\x20receive\x20dat\
    a\x20from\x20multiple\x20origins\n\x20typically\x20batch\x20the\x20data\
    \x20before\x20forwarding\x20further\x20and\x20in\x20that\x20case\x20this\
    \n\x20array\x20will\x20contain\x20multiple\x20elements.\n\n\x0c\n\x05\
    \x04\x02\x02\0\x04\x12\x03=\x02\n\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03=\
    \x0b\x1a\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03=\x1b+\n\x0c\n\x05\x04\x02\
    \x02\0\x03\x12\x03=./\n;\n\x02\x04\x03\x12\x04A\0N\x01\x1a/\x20A\x20coll\
    ection\x20of\x20ScopeMetrics\x20from\x20a\x20Resource.\n\n\n\n\x03\x04\
    \x03\x01\x12\x03A\x08\x17\n\n\n\x03\x04\x03\t\x12\x03B\x02\x10\n\x0b\n\
    \x04\x04\x03\t\0\x12\x03B\x0b\x0f\n\x0c\n\x05\x04\x03\t\0\x01\x12\x03B\
    \x0b\x0f\n\x0c\n\x05\x04\x03\t\0\x02\x12\x03B\x0b\x0f\nv\n\x04\x04\x03\
    \x02\0\x12\x03F\x02\x18\x1ai\x20The\x20resource\x20for\x20the\x20metrics\
    \x20in\x20this\x20message.\n\x20If\x20this\x20field\x20is\x20not\x20set\
    \x20then\x20no\x20resource\x20info\x20is\x20known.\n\n\x0c\n\x05\x04\x03\
    \x02\0\x06\x12\x03F\x02\n\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03F\x0b\x13\
    \n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03F\x16\x17\n@\n\x04\x04\x03\x02\x01\
    \x12\x03I\x02*\x1a3\x20A\x20list\x20of\x20metrics\x20that\x20originate\
    \x20from\x20a\x20resource.\n\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03I\
    \x02\n\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\x03I\x0b\x17\n\x0c\n\x05\x04\
    \x03\x02\x01\x01\x12\x03I\x18%\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03I(\
    )\n\xaf\x01\n\x04\x04\x03\x02\x02\x12\x03M\x02\x18\x1a\xa1\x01\x20This\
    \x20schema_url\x20applies\x20to\x20the\x20data\x20in\x20the\x20\"resourc\
    e\"\x20field.\x20It\x20does\x20not\x20apply\n\x20to\x20the\x20data\x20in\
    \x20the\x20\"scope_metrics\"\x20field\x20which\x20have\x20their\x20own\
    \x20schema_url\x20field.\n\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03M\x02\
    \x08\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03M\t\x13\n\x0c\n\x05\x04\x03\
    \x02\x02\x03\x12\x03M\x16\x17\n;\n\x02\x04\x04\x12\x04Q\0\\\x01\x1a/\x20\
    A\x20collection\x20of\x20Metrics\x20produced\x20by\x20an\x20Scope.\n\n\n\
    \n\x03\x04\x04\x01\x12\x03Q\x08\x14\n\xcf\x01\n\x04\x04\x04\x02\0\x12\
    \x03U\x02!\x1a\xc1\x01\x20The\x20instrumentation\x20scope\x20information\
    \x20for\x20the\x20metrics\x20in\x20this\x20message.\n\x20Semantically\
    \x20when\x20InstrumentationScope\x20isn't\x20set,\x20it\x20is\x20equival\
    ent\x20with\n\x20an\x20empty\x20instrumentation\x20scope\x20name\x20(unk\
    nown).\n\n\x0c\n\x05\x04\x04\x02\0\x06\x12\x03U\x02\x16\n\x0c\n\x05\x04\
    \x04\x02\0\x01\x12\x03U\x17\x1c\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03U\
    \x1f\x20\nP\n\x04\x04\x04\x02\x01\x12\x03X\x02\x1e\x1aC\x20A\x20list\x20\
    of\x20metrics\x20that\x20originate\x20from\x20an\x20instrumentation\x20l\
    ibrary.\n\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03X\x02\n\n\x0c\n\x05\x04\
    \x04\x02\x01\x06\x12\x03X\x0b\x11\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\
    \x03X\x12\x19\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03X\x1c\x1d\nM\n\x04\
    \x04\x04\x02\x02\x12\x03[\x02\x18\x1a@\x20This\x20schema_url\x20applies\
    \x20to\x20all\x20metrics\x20in\x20the\x20\"metrics\"\x20field.\n\n\x0c\n\
    \x05\x04\x04\x02\x02\x05\x12\x03[\x02\x08\n\x0c\n\x05\x04\x04\x02\x02\
    \x01\x12\x03[\t\x13\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03[\x16\x17\n\
    \xaf\x1d\n\x02\x04\x05\x12\x06\xb3\x01\0\xca\x01\x01\x1a\xa0\x1d\x20Defi\
    nes\x20a\x20Metric\x20which\x20has\x20one\x20or\x20more\x20timeseries.\
    \x20\x20The\x20following\x20is\x20a\n\x20brief\x20summary\x20of\x20the\
    \x20Metric\x20data\x20model.\x20\x20For\x20more\x20details,\x20see:\n\n\
    \x20\x20\x20https://github.com/open-telemetry/opentelemetry-specificatio\
    n/blob/main/specification/metrics/data-model.md\n\n\n\x20The\x20data\x20\
    model\x20and\x20relation\x20between\x20entities\x20is\x20shown\x20in\x20\
    the\n\x20diagram\x20below.\x20Here,\x20\"DataPoint\"\x20is\x20the\x20ter\
    m\x20used\x20to\x20refer\x20to\x20any\n\x20one\x20of\x20the\x20specific\
    \x20data\x20point\x20value\x20types,\x20and\x20\"points\"\x20is\x20the\
    \x20term\x20used\n\x20to\x20refer\x20to\x20any\x20one\x20of\x20the\x20li\
    sts\x20of\x20points\x20contained\x20in\x20the\x20Metric.\n\n\x20-\x20Met\
    ric\x20is\x20composed\x20of\x20a\x20metadata\x20and\x20data.\n\x20-\x20M\
    etadata\x20part\x20contains\x20a\x20name,\x20description,\x20unit.\n\x20\
    -\x20Data\x20is\x20one\x20of\x20the\x20possible\x20types\x20(Sum,\x20Gau\
    ge,\x20Histogram,\x20Summary).\n\x20-\x20DataPoint\x20contains\x20timest\
    amps,\x20attributes,\x20and\x20one\x20of\x20the\x20possible\x20value\x20\
    type\n\x20\x20\x20fields.\n\n\x20\x20\x20\x20\x20Metric\n\x20\x20+------\
    ------+\n\x20\x20|name\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20|descri\
    ption\x20|\n\x20\x20|unit\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20\x20\
    \x20\x20+------------------------------------+\n\x20\x20|data\x20\x20\
    \x20\x20\x20\x20\x20\x20|--->\x20|Gauge,\x20Sum,\x20Histogram,\x20Summar\
    y,\x20...\x20|\n\x20\x20+------------+\x20\x20\x20\x20\x20+-------------\
    -----------------------+\n\n\x20\x20\x20\x20Data\x20[One\x20of\x20Gauge,\
    \x20Sum,\x20Histogram,\x20Summary,\x20...]\n\x20\x20+-----------+\n\x20\
    \x20|...\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20//\x20Metadata\x20about\
    \x20the\x20Data.\n\x20\x20|points\x20\x20\x20\x20\x20|--+\n\x20\x20+----\
    -------+\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20|\x20\x20\x20\x20\x20\x20+---------------------------+\n\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\
    \x20\x20\x20\x20\x20\x20|DataPoint\x201\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20v\x20\x20\x20\x20\x20\x20|+------+------\
    +\x20\x20\x20+------+\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20+-----+\x20\x20\x20||label\x20|label\x20|...|label\x20|\x20|\
    \n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x201\x20\
    \x20|-->||value1|value2|...|valueN|\x20|\n\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20+-----+\x20\x20\x20|+------+------+\x20\x20\
    \x20+------+\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20|\x20\x20.\x20\x20|\x20\x20\x20|+-----+\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20.\x20\x20|\x20\x20\x20|\
    |value|\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20|\x20\x20.\x20\x20|\x20\x20\x20|+-----+\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20.\x20\x20|\x20\x20\x20+\
    ---------------------------+\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20|\x20\x20.\x20\x20|\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20.\n\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20|\x20\x20.\x20\x20|\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20.\n\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20.\x20\x20|\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20.\n\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20.\x20\x20|\
    \x20\x20\x20+---------------------------+\n\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20|\x20\x20.\x20\x20|\x20\x20\x20|DataPoint\
    \x20M\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20+-----+\x20\x20\
    \x20|+------+------+\x20\x20\x20+------+\x20|\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20|\x20\x20M\x20\x20|-->||label\x20|label\
    \x20|...|label\x20|\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20+-----+\x20\x20\x20||value1|value2|...|valueN|\x20|\n\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20|+------+------+\x20\x20\x20+------+\x20|\n\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20|+-----+\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20||value|\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20|\n\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20|+-----+\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20|\n\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20+---------------------------+\n\n\x20Each\x20distinct\x20type\x20of\
    \x20DataPoint\x20represents\x20the\x20output\x20of\x20a\x20specific\n\
    \x20aggregation\x20function,\x20the\x20result\x20of\x20applying\x20the\
    \x20DataPoint's\n\x20associated\x20function\x20of\x20to\x20one\x20or\x20\
    more\x20measurements.\n\n\x20All\x20DataPoint\x20types\x20have\x20three\
    \x20common\x20fields:\n\x20-\x20Attributes\x20includes\x20key-value\x20p\
    airs\x20associated\x20with\x20the\x20data\x20point\n\x20-\x20TimeUnixNan\
    o\x20is\x20required,\x20set\x20to\x20the\x20end\x20time\x20of\x20the\x20\
    aggregation\n\x20-\x20StartTimeUnixNano\x20is\x20optional,\x20but\x20str\
    ongly\x20encouraged\x20for\x20DataPoints\n\x20\x20\x20having\x20an\x20Ag\
    gregationTemporality\x20field,\x20as\x20discussed\x20below.\n\n\x20Both\
    \x20TimeUnixNano\x20and\x20StartTimeUnixNano\x20values\x20are\x20express\
    ed\x20as\n\x20UNIX\x20Epoch\x20time\x20in\x20nanoseconds\x20since\x2000:\
    00:00\x20UTC\x20on\x201\x20January\x201970.\n\n\x20#\x20TimeUnixNano\n\n\
    \x20This\x20field\x20is\x20required,\x20having\x20consistent\x20interpre\
    tation\x20across\n\x20DataPoint\x20types.\x20\x20TimeUnixNano\x20is\x20t\
    he\x20moment\x20corresponding\x20to\x20when\n\x20the\x20data\x20point's\
    \x20aggregate\x20value\x20was\x20captured.\n\n\x20Data\x20points\x20with\
    \x20the\x200\x20value\x20for\x20TimeUnixNano\x20SHOULD\x20be\x20rejected\
    \n\x20by\x20consumers.\n\n\x20#\x20StartTimeUnixNano\n\n\x20StartTimeUni\
    xNano\x20in\x20general\x20allows\x20detecting\x20when\x20a\x20sequence\
    \x20of\n\x20observations\x20is\x20unbroken.\x20\x20This\x20field\x20indi\
    cates\x20to\x20consumers\x20the\n\x20start\x20time\x20for\x20points\x20w\
    ith\x20cumulative\x20and\x20delta\n\x20AggregationTemporality,\x20and\
    \x20it\x20should\x20be\x20included\x20whenever\x20possible\n\x20to\x20su\
    pport\x20correct\x20rate\x20calculation.\x20\x20Although\x20it\x20may\
    \x20be\x20omitted\n\x20when\x20the\x20start\x20time\x20is\x20truly\x20un\
    known,\x20setting\x20StartTimeUnixNano\x20is\n\x20strongly\x20encouraged\
    .\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xb3\x01\x08\x0e\n\x0b\n\x03\x04\x05\
    \t\x12\x04\xb4\x01\x02\x13\n\x0c\n\x04\x04\x05\t\0\x12\x04\xb4\x01\x0b\
    \x0c\n\r\n\x05\x04\x05\t\0\x01\x12\x04\xb4\x01\x0b\x0c\n\r\n\x05\x04\x05\
    \t\0\x02\x12\x04\xb4\x01\x0b\x0c\n\x0c\n\x04\x04\x05\t\x01\x12\x04\xb4\
    \x01\x0e\x0f\n\r\n\x05\x04\x05\t\x01\x01\x12\x04\xb4\x01\x0e\x0f\n\r\n\
    \x05\x04\x05\t\x01\x02\x12\x04\xb4\x01\x0e\x0f\n\x0c\n\x04\x04\x05\t\x02\
    \x12\x04\xb4\x01\x11\x12\n\r\n\x05\x04\x05\t\x02\x01\x12\x04\xb4\x01\x11\
    \x12\n\r\n\x05\x04\x05\t\x02\x02\x12\x04\xb4\x01\x11\x12\nU\n\x04\x04\
    \x05\x02\0\x12\x04\xb7\x01\x02\x12\x1aG\x20name\x20of\x20the\x20metric,\
    \x20including\x20its\x20DNS\x20name\x20prefix.\x20It\x20must\x20be\x20un\
    ique.\n\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xb7\x01\x02\x08\n\r\n\x05\
    \x04\x05\x02\0\x01\x12\x04\xb7\x01\t\r\n\r\n\x05\x04\x05\x02\0\x03\x12\
    \x04\xb7\x01\x10\x11\nN\n\x04\x04\x05\x02\x01\x12\x04\xba\x01\x02\x19\
    \x1a@\x20description\x20of\x20the\x20metric,\x20which\x20can\x20be\x20us\
    ed\x20in\x20documentation.\n\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\xba\
    \x01\x02\x08\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\xba\x01\t\x14\n\r\n\
    \x05\x04\x05\x02\x01\x03\x12\x04\xba\x01\x17\x18\n\x81\x01\n\x04\x04\x05\
    \x02\x02\x12\x04\xbe\x01\x02\x12\x1as\x20unit\x20in\x20which\x20the\x20m\
    etric\x20value\x20is\x20reported.\x20Follows\x20the\x20format\n\x20descr\
    ibed\x20by\x20http://unitsofmeasure.org/ucum.html.\n\n\r\n\x05\x04\x05\
    \x02\x02\x05\x12\x04\xbe\x01\x02\x08\n\r\n\x05\x04\x05\x02\x02\x01\x12\
    \x04\xbe\x01\t\r\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\xbe\x01\x10\x11\n\
    \xd7\x01\n\x04\x04\x05\x08\0\x12\x06\xc3\x01\x02\xc9\x01\x03\x1a\xc6\x01\
    \x20Data\x20determines\x20the\x20aggregation\x20type\x20(if\x20any)\x20o\
    f\x20the\x20metric,\x20what\x20is\x20the\n\x20reported\x20value\x20type\
    \x20for\x20the\x20data\x20points,\x20as\x20well\x20as\x20the\x20relatati\
    onship\x20to\n\x20the\x20time\x20interval\x20over\x20which\x20they\x20ar\
    e\x20reported.\n\n\r\n\x05\x04\x05\x08\0\x01\x12\x04\xc3\x01\x08\x0c\n\
    \x0c\n\x04\x04\x05\x02\x03\x12\x04\xc4\x01\x04\x14\n\r\n\x05\x04\x05\x02\
    \x03\x06\x12\x04\xc4\x01\x04\t\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\xc4\
    \x01\n\x0f\n\r\n\x05\x04\x05\x02\x03\x03\x12\x04\xc4\x01\x12\x13\n\x0c\n\
    \x04\x04\x05\x02\x04\x12\x04\xc5\x01\x04\x10\n\r\n\x05\x04\x05\x02\x04\
    \x06\x12\x04\xc5\x01\x04\x07\n\r\n\x05\x04\x05\x02\x04\x01\x12\x04\xc5\
    \x01\x08\x0b\n\r\n\x05\x04\x05\x02\x04\x03\x12\x04\xc5\x01\x0e\x0f\n\x0c\
    \n\x04\x04\x05\x02\x05\x12\x04\xc6\x01\x04\x1c\n\r\n\x05\x04\x05\x02\x05\
    \x06\x12\x04\xc6\x01\x04\r\n\r\n\x05\x04\x05\x02\x05\x01\x12\x04\xc6\x01\
    \x0e\x17\n\r\n\x05\x04\x05\x02\x05\x03\x12\x04\xc6\x01\x1a\x1b\n\x0c\n\
    \x04\x04\x05\x02\x06\x12\x04\xc7\x01\x044\n\r\n\x05\x04\x05\x02\x06\x06\
    \x12\x04\xc7\x01\x04\x18\n\r\n\x05\x04\x05\x02\x06\x01\x12\x04\xc7\x01\
    \x19.\n\r\n\x05\x04\x05\x02\x06\x03\x12\x04\xc7\x0113\n\x0c\n\x04\x04\
    \x05\x02\x07\x12\x04\xc8\x01\x04\x19\n\r\n\x05\x04\x05\x02\x07\x06\x12\
    \x04\xc8\x01\x04\x0b\n\r\n\x05\x04\x05\x02\x07\x01\x12\x04\xc8\x01\x0c\
    \x13\n\r\n\x05\x04\x05\x02\x07\x03\x12\x04\xc8\x01\x16\x18\n\xf7\x03\n\
    \x02\x04\x06\x12\x06\xd5\x01\0\xd7\x01\x01\x1a\xe8\x03\x20Gauge\x20repre\
    sents\x20the\x20type\x20of\x20a\x20scalar\x20metric\x20that\x20always\
    \x20exports\x20the\n\x20\"current\x20value\"\x20for\x20every\x20data\x20\
    point.\x20It\x20should\x20be\x20used\x20for\x20an\x20\"unknown\"\n\x20ag\
    gregation.\n\n\x20A\x20Gauge\x20does\x20not\x20support\x20different\x20a\
    ggregation\x20temporalities.\x20Given\x20the\n\x20aggregation\x20is\x20u\
    nknown,\x20points\x20cannot\x20be\x20combined\x20using\x20the\x20same\n\
    \x20aggregation,\x20regardless\x20of\x20aggregation\x20temporalities.\
    \x20Therefore,\n\x20AggregationTemporality\x20is\x20not\x20included.\x20\
    Consequently,\x20this\x20also\x20means\n\x20\"StartTimeUnixNano\"\x20is\
    \x20ignored\x20for\x20all\x20data\x20points.\n\n\x0b\n\x03\x04\x06\x01\
    \x12\x04\xd5\x01\x08\r\n\x0c\n\x04\x04\x06\x02\0\x12\x04\xd6\x01\x02+\n\
    \r\n\x05\x04\x06\x02\0\x04\x12\x04\xd6\x01\x02\n\n\r\n\x05\x04\x06\x02\0\
    \x06\x12\x04\xd6\x01\x0b\x1a\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xd6\x01\
    \x1b&\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xd6\x01)*\n\x8a\x01\n\x02\x04\
    \x07\x12\x06\xdb\x01\0\xe4\x01\x01\x1a|\x20Sum\x20represents\x20the\x20t\
    ype\x20of\x20a\x20scalar\x20metric\x20that\x20is\x20calculated\x20as\x20\
    a\x20sum\x20of\x20all\n\x20reported\x20measurements\x20over\x20a\x20time\
    \x20interval.\n\n\x0b\n\x03\x04\x07\x01\x12\x04\xdb\x01\x08\x0b\n\x0c\n\
    \x04\x04\x07\x02\0\x12\x04\xdc\x01\x02+\n\r\n\x05\x04\x07\x02\0\x04\x12\
    \x04\xdc\x01\x02\n\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\xdc\x01\x0b\x1a\n\
    \r\n\x05\x04\x07\x02\0\x01\x12\x04\xdc\x01\x1b&\n\r\n\x05\x04\x07\x02\0\
    \x03\x12\x04\xdc\x01)*\n\xa3\x01\n\x04\x04\x07\x02\x01\x12\x04\xe0\x01\
    \x025\x1a\x94\x01\x20aggregation_temporality\x20describes\x20if\x20the\
    \x20aggregator\x20reports\x20delta\x20changes\n\x20since\x20last\x20repo\
    rt\x20time,\x20or\x20cumulative\x20changes\x20since\x20a\x20fixed\x20sta\
    rt\x20time.\n\n\r\n\x05\x04\x07\x02\x01\x06\x12\x04\xe0\x01\x02\x18\n\r\
    \n\x05\x04\x07\x02\x01\x01\x12\x04\xe0\x01\x190\n\r\n\x05\x04\x07\x02\
    \x01\x03\x12\x04\xe0\x0134\n:\n\x04\x04\x07\x02\x02\x12\x04\xe3\x01\x02\
    \x18\x1a,\x20If\x20\"true\"\x20means\x20that\x20the\x20sum\x20is\x20mono\
    tonic.\n\n\r\n\x05\x04\x07\x02\x02\x05\x12\x04\xe3\x01\x02\x06\n\r\n\x05\
    \x04\x07\x02\x02\x01\x12\x04\xe3\x01\x07\x13\n\r\n\x05\x04\x07\x02\x02\
    \x03\x12\x04\xe3\x01\x16\x17\n\x9f\x01\n\x02\x04\x08\x12\x06\xe8\x01\0\
    \xee\x01\x01\x1a\x90\x01\x20Histogram\x20represents\x20the\x20type\x20of\
    \x20a\x20metric\x20that\x20is\x20calculated\x20by\x20aggregating\n\x20as\
    \x20a\x20Histogram\x20of\x20all\x20reported\x20measurements\x20over\x20a\
    \x20time\x20interval.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xe8\x01\x08\x11\
    \n\x0c\n\x04\x04\x08\x02\0\x12\x04\xe9\x01\x02.\n\r\n\x05\x04\x08\x02\0\
    \x04\x12\x04\xe9\x01\x02\n\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\xe9\x01\
    \x0b\x1d\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xe9\x01\x1e)\n\r\n\x05\x04\
    \x08\x02\0\x03\x12\x04\xe9\x01,-\n\xa3\x01\n\x04\x04\x08\x02\x01\x12\x04\
    \xed\x01\x025\x1a\x94\x01\x20aggregation_temporality\x20describes\x20if\
    \x20the\x20aggregator\x20reports\x20delta\x20changes\n\x20since\x20last\
    \x20report\x20time,\x20or\x20cumulative\x20changes\x20since\x20a\x20fixe\
    d\x20start\x20time.\n\n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\xed\x01\x02\
    \x18\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xed\x01\x190\n\r\n\x05\x04\
    \x08\x02\x01\x03\x12\x04\xed\x0134\n\xbc\x01\n\x02\x04\t\x12\x06\xf2\x01\
    \0\xf8\x01\x01\x1a\xad\x01\x20ExponentialHistogram\x20represents\x20the\
    \x20type\x20of\x20a\x20metric\x20that\x20is\x20calculated\x20by\x20aggre\
    gating\n\x20as\x20a\x20ExponentialHistogram\x20of\x20all\x20reported\x20\
    double\x20measurements\x20over\x20a\x20time\x20interval.\n\n\x0b\n\x03\
    \x04\t\x01\x12\x04\xf2\x01\x08\x1c\n\x0c\n\x04\x04\t\x02\0\x12\x04\xf3\
    \x01\x029\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xf3\x01\x02\n\n\r\n\x05\x04\
    \t\x02\0\x06\x12\x04\xf3\x01\x0b(\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xf3\
    \x01)4\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xf3\x0178\n\xa3\x01\n\x04\x04\t\
    \x02\x01\x12\x04\xf7\x01\x025\x1a\x94\x01\x20aggregation_temporality\x20\
    describes\x20if\x20the\x20aggregator\x20reports\x20delta\x20changes\n\
    \x20since\x20last\x20report\x20time,\x20or\x20cumulative\x20changes\x20s\
    ince\x20a\x20fixed\x20start\x20time.\n\n\r\n\x05\x04\t\x02\x01\x06\x12\
    \x04\xf7\x01\x02\x18\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xf7\x01\x190\n\
    \r\n\x05\x04\t\x02\x01\x03\x12\x04\xf7\x0134\n\xe5\x03\n\x02\x04\n\x12\
    \x06\x80\x02\0\x82\x02\x01\x1a\xd6\x03\x20Summary\x20metric\x20data\x20a\
    re\x20used\x20to\x20convey\x20quantile\x20summaries,\n\x20a\x20Prometheu\
    s\x20(see:\x20https://prometheus.io/docs/concepts/metric_types/#summary)\
    \n\x20and\x20OpenMetrics\x20(see:\x20https://github.com/OpenObservabilit\
    y/OpenMetrics/blob/4dbf6075567ab43296eed941037c12951faafb92/protos/prome\
    theus.proto#L45)\n\x20data\x20type.\x20These\x20data\x20points\x20cannot\
    \x20always\x20be\x20merged\x20in\x20a\x20meaningful\x20way.\n\x20While\
    \x20they\x20can\x20be\x20useful\x20in\x20some\x20applications,\x20histog\
    ram\x20data\x20points\x20are\n\x20recommended\x20for\x20new\x20applicati\
    ons.\n\n\x0b\n\x03\x04\n\x01\x12\x04\x80\x02\x08\x0f\n\x0c\n\x04\x04\n\
    \x02\0\x12\x04\x81\x02\x02,\n\r\n\x05\x04\n\x02\0\x04\x12\x04\x81\x02\
    \x02\n\n\r\n\x05\x04\n\x02\0\x06\x12\x04\x81\x02\x0b\x1b\n\r\n\x05\x04\n\
    \x02\0\x01\x12\x04\x81\x02\x1c'\n\r\n\x05\x04\n\x02\0\x03\x12\x04\x81\
    \x02*+\n\xbe\x01\n\x02\x05\0\x12\x06\x87\x02\0\xc9\x02\x01\x1a\xaf\x01\
    \x20AggregationTemporality\x20defines\x20how\x20a\x20metric\x20aggregato\
    r\x20reports\x20aggregated\n\x20values.\x20It\x20describes\x20how\x20tho\
    se\x20values\x20relate\x20to\x20the\x20time\x20interval\x20over\n\x20whi\
    ch\x20they\x20are\x20aggregated.\n\n\x0b\n\x03\x05\0\x01\x12\x04\x87\x02\
    \x05\x1b\nW\n\x04\x05\0\x02\0\x12\x04\x89\x02\x02*\x1aI\x20UNSPECIFIED\
    \x20is\x20the\x20default\x20AggregationTemporality,\x20it\x20MUST\x20not\
    \x20be\x20used.\n\n\r\n\x05\x05\0\x02\0\x01\x12\x04\x89\x02\x02%\n\r\n\
    \x05\x05\0\x02\0\x02\x12\x04\x89\x02()\n\xec\t\n\x04\x05\0\x02\x01\x12\
    \x04\xa3\x02\x02$\x1a\xdd\t\x20DELTA\x20is\x20an\x20AggregationTemporali\
    ty\x20for\x20a\x20metric\x20aggregator\x20which\x20reports\n\x20changes\
    \x20since\x20last\x20report\x20time.\x20Successive\x20metrics\x20contain\
    \x20aggregation\x20of\n\x20values\x20from\x20continuous\x20and\x20non-ov\
    erlapping\x20intervals.\n\n\x20The\x20values\x20for\x20a\x20DELTA\x20met\
    ric\x20are\x20based\x20only\x20on\x20the\x20time\x20interval\n\x20associ\
    ated\x20with\x20one\x20measurement\x20cycle.\x20There\x20is\x20no\x20dep\
    endency\x20on\n\x20previous\x20measurements\x20like\x20is\x20the\x20case\
    \x20for\x20CUMULATIVE\x20metrics.\n\n\x20For\x20example,\x20consider\x20\
    a\x20system\x20measuring\x20the\x20number\x20of\x20requests\x20that\n\
    \x20it\x20receives\x20and\x20reports\x20the\x20sum\x20of\x20these\x20req\
    uests\x20every\x20second\x20as\x20a\n\x20DELTA\x20metric:\n\n\x20\x20\
    \x201.\x20The\x20system\x20starts\x20receiving\x20at\x20time=t_0.\n\x20\
    \x20\x202.\x20A\x20request\x20is\x20received,\x20the\x20system\x20measur\
    es\x201\x20request.\n\x20\x20\x203.\x20A\x20request\x20is\x20received,\
    \x20the\x20system\x20measures\x201\x20request.\n\x20\x20\x204.\x20A\x20r\
    equest\x20is\x20received,\x20the\x20system\x20measures\x201\x20request.\
    \n\x20\x20\x205.\x20The\x201\x20second\x20collection\x20cycle\x20ends.\
    \x20A\x20metric\x20is\x20exported\x20for\x20the\n\x20\x20\x20\x20\x20\
    \x20number\x20of\x20requests\x20received\x20over\x20the\x20interval\x20o\
    f\x20time\x20t_0\x20to\n\x20\x20\x20\x20\x20\x20t_0+1\x20with\x20a\x20va\
    lue\x20of\x203.\n\x20\x20\x206.\x20A\x20request\x20is\x20received,\x20th\
    e\x20system\x20measures\x201\x20request.\n\x20\x20\x207.\x20A\x20request\
    \x20is\x20received,\x20the\x20system\x20measures\x201\x20request.\n\x20\
    \x20\x208.\x20The\x201\x20second\x20collection\x20cycle\x20ends.\x20A\
    \x20metric\x20is\x20exported\x20for\x20the\n\x20\x20\x20\x20\x20\x20numb\
    er\x20of\x20requests\x20received\x20over\x20the\x20interval\x20of\x20tim\
    e\x20t_0+1\x20to\n\x20\x20\x20\x20\x20\x20t_0+2\x20with\x20a\x20value\
    \x20of\x202.\n\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\xa3\x02\x02\x1f\n\r\n\
    \x05\x05\0\x02\x01\x02\x12\x04\xa3\x02\"#\n\x93\x0f\n\x04\x05\0\x02\x02\
    \x12\x04\xc8\x02\x02)\x1a\x84\x0f\x20CUMULATIVE\x20is\x20an\x20Aggregati\
    onTemporality\x20for\x20a\x20metric\x20aggregator\x20which\n\x20reports\
    \x20changes\x20since\x20a\x20fixed\x20start\x20time.\x20This\x20means\
    \x20that\x20current\x20values\n\x20of\x20a\x20CUMULATIVE\x20metric\x20de\
    pend\x20on\x20all\x20previous\x20measurements\x20since\x20the\n\x20start\
    \x20time.\x20Because\x20of\x20this,\x20the\x20sender\x20is\x20required\
    \x20to\x20retain\x20this\x20state\n\x20in\x20some\x20form.\x20If\x20this\
    \x20state\x20is\x20lost\x20or\x20invalidated,\x20the\x20CUMULATIVE\x20me\
    tric\n\x20values\x20MUST\x20be\x20reset\x20and\x20a\x20new\x20fixed\x20s\
    tart\x20time\x20following\x20the\x20last\n\x20reported\x20measurement\
    \x20time\x20sent\x20MUST\x20be\x20used.\n\n\x20For\x20example,\x20consid\
    er\x20a\x20system\x20measuring\x20the\x20number\x20of\x20requests\x20tha\
    t\n\x20it\x20receives\x20and\x20reports\x20the\x20sum\x20of\x20these\x20\
    requests\x20every\x20second\x20as\x20a\n\x20CUMULATIVE\x20metric:\n\n\
    \x20\x20\x201.\x20The\x20system\x20starts\x20receiving\x20at\x20time=t_0\
    .\n\x20\x20\x202.\x20A\x20request\x20is\x20received,\x20the\x20system\
    \x20measures\x201\x20request.\n\x20\x20\x203.\x20A\x20request\x20is\x20r\
    eceived,\x20the\x20system\x20measures\x201\x20request.\n\x20\x20\x204.\
    \x20A\x20request\x20is\x20received,\x20the\x20system\x20measures\x201\
    \x20request.\n\x20\x20\x205.\x20The\x201\x20second\x20collection\x20cycl\
    e\x20ends.\x20A\x20metric\x20is\x20exported\x20for\x20the\n\x20\x20\x20\
    \x20\x20\x20number\x20of\x20requests\x20received\x20over\x20the\x20inter\
    val\x20of\x20time\x20t_0\x20to\n\x20\x20\x20\x20\x20\x20t_0+1\x20with\
    \x20a\x20value\x20of\x203.\n\x20\x20\x206.\x20A\x20request\x20is\x20rece\
    ived,\x20the\x20system\x20measures\x201\x20request.\n\x20\x20\x207.\x20A\
    \x20request\x20is\x20received,\x20the\x20system\x20measures\x201\x20requ\
    est.\n\x20\x20\x208.\x20The\x201\x20second\x20collection\x20cycle\x20end\
    s.\x20A\x20metric\x20is\x20exported\x20for\x20the\n\x20\x20\x20\x20\x20\
    \x20number\x20of\x20requests\x20received\x20over\x20the\x20interval\x20o\
    f\x20time\x20t_0\x20to\n\x20\x20\x20\x20\x20\x20t_0+2\x20with\x20a\x20va\
    lue\x20of\x205.\n\x20\x20\x209.\x20The\x20system\x20experiences\x20a\x20\
    fault\x20and\x20loses\x20state.\n\x20\x20\x2010.\x20The\x20system\x20rec\
    overs\x20and\x20resumes\x20receiving\x20at\x20time=t_1.\n\x20\x20\x2011.\
    \x20A\x20request\x20is\x20received,\x20the\x20system\x20measures\x201\
    \x20request.\n\x20\x20\x2012.\x20The\x201\x20second\x20collection\x20cyc\
    le\x20ends.\x20A\x20metric\x20is\x20exported\x20for\x20the\n\x20\x20\x20\
    \x20\x20\x20number\x20of\x20requests\x20received\x20over\x20the\x20inter\
    val\x20of\x20time\x20t_1\x20to\n\x20\x20\x20\x20\x20\x20t_0+1\x20with\
    \x20a\x20value\x20of\x201.\n\n\x20Note:\x20Even\x20though,\x20when\x20re\
    porting\x20changes\x20since\x20last\x20report\x20time,\x20using\n\x20CUM\
    ULATIVE\x20is\x20valid,\x20it\x20is\x20not\x20recommended.\x20This\x20ma\
    y\x20cause\x20problems\x20for\n\x20systems\x20that\x20do\x20not\x20use\
    \x20start_time\x20to\x20determine\x20when\x20the\x20aggregation\n\x20val\
    ue\x20was\x20reset\x20(e.g.\x20Prometheus).\n\n\r\n\x05\x05\0\x02\x02\
    \x01\x12\x04\xc8\x02\x02$\n\r\n\x05\x05\0\x02\x02\x02\x12\x04\xc8\x02'(\
    \n\xf1\x02\n\x02\x05\x01\x12\x06\xd2\x02\0\xdb\x02\x01\x1a\xe2\x02\x20Da\
    taPointFlags\x20is\x20defined\x20as\x20a\x20protobuf\x20'uint32'\x20type\
    \x20and\x20is\x20to\x20be\x20used\x20as\x20a\n\x20bit-field\x20represent\
    ing\x2032\x20distinct\x20boolean\x20flags.\x20\x20Each\x20flag\x20define\
    d\x20in\x20this\n\x20enum\x20is\x20a\x20bit-mask.\x20\x20To\x20test\x20t\
    he\x20presence\x20of\x20a\x20single\x20flag\x20in\x20the\x20flags\x20of\
    \n\x20a\x20data\x20point,\x20for\x20example,\x20use\x20an\x20expression\
    \x20like:\n\n\x20\x20\x20(point.flags\x20&\x20FLAG_NO_RECORDED_VALUE)\
    \x20==\x20FLAG_NO_RECORDED_VALUE\n\n\n\x0b\n\x03\x05\x01\x01\x12\x04\xd2\
    \x02\x05\x13\n\x0c\n\x04\x05\x01\x02\0\x12\x04\xd3\x02\x02\x10\n\r\n\x05\
    \x05\x01\x02\0\x01\x12\x04\xd3\x02\x02\x0b\n\r\n\x05\x05\x01\x02\0\x02\
    \x12\x04\xd3\x02\x0e\x0f\n\xcb\x01\n\x04\x05\x01\x02\x01\x12\x04\xd8\x02\
    \x02\x1d\x1a\xbc\x01\x20This\x20DataPoint\x20is\x20valid\x20but\x20has\
    \x20no\x20recorded\x20value.\x20\x20This\x20value\n\x20SHOULD\x20be\x20u\
    sed\x20to\x20reflect\x20explicitly\x20missing\x20data\x20in\x20a\x20seri\
    es,\x20as\n\x20for\x20an\x20equivalent\x20to\x20the\x20Prometheus\x20\"s\
    taleness\x20marker\".\n\n\r\n\x05\x05\x01\x02\x01\x01\x12\x04\xd8\x02\
    \x02\x18\n\r\n\x05\x05\x01\x02\x01\x02\x12\x04\xd8\x02\x1b\x1c\n\x81\x01\
    \n\x02\x04\x0b\x12\x06\xdf\x02\0\x83\x03\x01\x1as\x20NumberDataPoint\x20\
    is\x20a\x20single\x20data\x20point\x20in\x20a\x20timeseries\x20that\x20d\
    escribes\x20the\n\x20time-varying\x20scalar\x20value\x20of\x20a\x20metri\
    c.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xdf\x02\x08\x17\n\x0b\n\x03\x04\x0b\
    \t\x12\x04\xe0\x02\x02\r\n\x0c\n\x04\x04\x0b\t\0\x12\x04\xe0\x02\x0b\x0c\
    \n\r\n\x05\x04\x0b\t\0\x01\x12\x04\xe0\x02\x0b\x0c\n\r\n\x05\x04\x0b\t\0\
    \x02\x12\x04\xe0\x02\x0b\x0c\n\x88\x02\n\x04\x04\x0b\x02\0\x12\x04\xe6\
    \x02\x02#\x1a\xf9\x01\x20The\x20set\x20of\x20key/value\x20pairs\x20that\
    \x20uniquely\x20identify\x20the\x20timeseries\x20from\n\x20where\x20this\
    \x20point\x20belongs.\x20The\x20list\x20may\x20be\x20empty\x20(may\x20co\
    ntain\x200\x20elements).\n\x20Attribute\x20keys\x20MUST\x20be\x20unique\
    \x20(it\x20is\x20not\x20allowed\x20to\x20have\x20more\x20than\x20one\n\
    \x20attribute\x20with\x20the\x20same\x20key).\n\n\r\n\x05\x04\x0b\x02\0\
    \x04\x12\x04\xe6\x02\x02\n\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\xe6\x02\
    \x0b\x13\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xe6\x02\x14\x1e\n\r\n\x05\
    \x04\x0b\x02\0\x03\x12\x04\xe6\x02!\"\n\xc5\x01\n\x04\x04\x0b\x02\x01\
    \x12\x04\xed\x02\x02#\x1a\xb6\x01\x20StartTimeUnixNano\x20is\x20optional\
    \x20but\x20strongly\x20encouraged,\x20see\x20the\n\x20the\x20detailed\
    \x20comments\x20above\x20Metric.\n\n\x20Value\x20is\x20UNIX\x20Epoch\x20\
    time\x20in\x20nanoseconds\x20since\x2000:00:00\x20UTC\x20on\x201\x20Janu\
    ary\n\x201970.\n\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xed\x02\x02\t\n\r\
    \n\x05\x04\x0b\x02\x01\x01\x12\x04\xed\x02\n\x1e\n\r\n\x05\x04\x0b\x02\
    \x01\x03\x12\x04\xed\x02!\"\n\xa3\x01\n\x04\x04\x0b\x02\x02\x12\x04\xf3\
    \x02\x02\x1d\x1a\x94\x01\x20TimeUnixNano\x20is\x20required,\x20see\x20th\
    e\x20detailed\x20comments\x20above\x20Metric.\n\n\x20Value\x20is\x20UNIX\
    \x20Epoch\x20time\x20in\x20nanoseconds\x20since\x2000:00:00\x20UTC\x20on\
    \x201\x20January\n\x201970.\n\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\xf3\
    \x02\x02\t\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\xf3\x02\n\x18\n\r\n\x05\
    \x04\x0b\x02\x02\x03\x12\x04\xf3\x02\x1b\x1c\n\x8d\x01\n\x04\x04\x0b\x08\
    \0\x12\x06\xf7\x02\x02\xfa\x02\x03\x1a}\x20The\x20value\x20itself.\x20\
    \x20A\x20point\x20is\x20considered\x20invalid\x20when\x20one\x20of\x20th\
    e\x20recognized\n\x20value\x20fields\x20is\x20not\x20present\x20inside\
    \x20this\x20oneof.\n\n\r\n\x05\x04\x0b\x08\0\x01\x12\x04\xf7\x02\x08\r\n\
    \x0c\n\x04\x04\x0b\x02\x03\x12\x04\xf8\x02\x04\x19\n\r\n\x05\x04\x0b\x02\
    \x03\x05\x12\x04\xf8\x02\x04\n\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\xf8\
    \x02\x0b\x14\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\xf8\x02\x17\x18\n\x0c\
    \n\x04\x04\x0b\x02\x04\x12\x04\xf9\x02\x04\x18\n\r\n\x05\x04\x0b\x02\x04\
    \x05\x12\x04\xf9\x02\x04\x0c\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\xf9\
    \x02\r\x13\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\xf9\x02\x16\x17\no\n\
    \x04\x04\x0b\x02\x05\x12\x04\xfe\x02\x02\"\x1aa\x20(Optional)\x20List\
    \x20of\x20exemplars\x20collected\x20from\n\x20measurements\x20that\x20we\
    re\x20used\x20to\x20form\x20the\x20data\x20point\n\n\r\n\x05\x04\x0b\x02\
    \x05\x04\x12\x04\xfe\x02\x02\n\n\r\n\x05\x04\x0b\x02\x05\x06\x12\x04\xfe\
    \x02\x0b\x13\n\r\n\x05\x04\x0b\x02\x05\x01\x12\x04\xfe\x02\x14\x1d\n\r\n\
    \x05\x04\x0b\x02\x05\x03\x12\x04\xfe\x02\x20!\n}\n\x04\x04\x0b\x02\x06\
    \x12\x04\x82\x03\x02\x13\x1ao\x20Flags\x20that\x20apply\x20to\x20this\
    \x20specific\x20data\x20point.\x20\x20See\x20DataPointFlags\n\x20for\x20\
    the\x20available\x20flags\x20and\x20their\x20meaning.\n\n\r\n\x05\x04\
    \x0b\x02\x06\x05\x12\x04\x82\x03\x02\x08\n\r\n\x05\x04\x0b\x02\x06\x01\
    \x12\x04\x82\x03\t\x0e\n\r\n\x05\x04\x0b\x02\x06\x03\x12\x04\x82\x03\x11\
    \x12\n\xc4\x04\n\x02\x04\x0c\x12\x06\x8f\x03\0\xd9\x03\x01\x1a\xb5\x04\
    \x20HistogramDataPoint\x20is\x20a\x20single\x20data\x20point\x20in\x20a\
    \x20timeseries\x20that\x20describes\x20the\n\x20time-varying\x20values\
    \x20of\x20a\x20Histogram.\x20A\x20Histogram\x20contains\x20summary\x20st\
    atistics\n\x20for\x20a\x20population\x20of\x20values,\x20it\x20may\x20op\
    tionally\x20contain\x20the\x20distribution\x20of\n\x20those\x20values\
    \x20across\x20a\x20set\x20of\x20buckets.\n\n\x20If\x20the\x20histogram\
    \x20contains\x20the\x20distribution\x20of\x20values,\x20then\x20both\n\
    \x20\"explicit_bounds\"\x20and\x20\"bucket\x20counts\"\x20fields\x20must\
    \x20be\x20defined.\n\x20If\x20the\x20histogram\x20does\x20not\x20contain\
    \x20the\x20distribution\x20of\x20values,\x20then\x20both\n\x20\"explicit\
    _bounds\"\x20and\x20\"bucket_counts\"\x20must\x20be\x20omitted\x20and\
    \x20only\x20\"count\"\x20and\n\x20\"sum\"\x20are\x20known.\n\n\x0b\n\x03\
    \x04\x0c\x01\x12\x04\x8f\x03\x08\x1a\n\x0b\n\x03\x04\x0c\t\x12\x04\x90\
    \x03\x02\r\n\x0c\n\x04\x04\x0c\t\0\x12\x04\x90\x03\x0b\x0c\n\r\n\x05\x04\
    \x0c\t\0\x01\x12\x04\x90\x03\x0b\x0c\n\r\n\x05\x04\x0c\t\0\x02\x12\x04\
    \x90\x03\x0b\x0c\n\x88\x02\n\x04\x04\x0c\x02\0\x12\x04\x96\x03\x02#\x1a\
    \xf9\x01\x20The\x20set\x20of\x20key/value\x20pairs\x20that\x20uniquely\
    \x20identify\x20the\x20timeseries\x20from\n\x20where\x20this\x20point\
    \x20belongs.\x20The\x20list\x20may\x20be\x20empty\x20(may\x20contain\x20\
    0\x20elements).\n\x20Attribute\x20keys\x20MUST\x20be\x20unique\x20(it\
    \x20is\x20not\x20allowed\x20to\x20have\x20more\x20than\x20one\n\x20attri\
    bute\x20with\x20the\x20same\x20key).\n\n\r\n\x05\x04\x0c\x02\0\x04\x12\
    \x04\x96\x03\x02\n\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\x96\x03\x0b\x13\n\
    \r\n\x05\x04\x0c\x02\0\x01\x12\x04\x96\x03\x14\x1e\n\r\n\x05\x04\x0c\x02\
    \0\x03\x12\x04\x96\x03!\"\n\xc5\x01\n\x04\x04\x0c\x02\x01\x12\x04\x9d\
    \x03\x02#\x1a\xb6\x01\x20StartTimeUnixNano\x20is\x20optional\x20but\x20s\
    trongly\x20encouraged,\x20see\x20the\n\x20the\x20detailed\x20comments\
    \x20above\x20Metric.\n\n\x20Value\x20is\x20UNIX\x20Epoch\x20time\x20in\
    \x20nanoseconds\x20since\x2000:00:00\x20UTC\x20on\x201\x20January\n\x201\
    970.\n\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\x9d\x03\x02\t\n\r\n\x05\x04\
    \x0c\x02\x01\x01\x12\x04\x9d\x03\n\x1e\n\r\n\x05\x04\x0c\x02\x01\x03\x12\
    \x04\x9d\x03!\"\n\xa3\x01\n\x04\x04\x0c\x02\x02\x12\x04\xa3\x03\x02\x1d\
    \x1a\x94\x01\x20TimeUnixNano\x20is\x20required,\x20see\x20the\x20detaile\
    d\x20comments\x20above\x20Metric.\n\n\x20Value\x20is\x20UNIX\x20Epoch\
    \x20time\x20in\x20nanoseconds\x20since\x2000:00:00\x20UTC\x20on\x201\x20\
    January\n\x201970.\n\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\xa3\x03\x02\t\
    \n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xa3\x03\n\x18\n\r\n\x05\x04\x0c\
    \x02\x02\x03\x12\x04\xa3\x03\x1b\x1c\n\xba\x01\n\x04\x04\x0c\x02\x03\x12\
    \x04\xa8\x03\x02\x14\x1a\xab\x01\x20count\x20is\x20the\x20number\x20of\
    \x20values\x20in\x20the\x20population.\x20Must\x20be\x20non-negative.\
    \x20This\n\x20value\x20must\x20be\x20equal\x20to\x20the\x20sum\x20of\x20\
    the\x20\"count\"\x20fields\x20in\x20buckets\x20if\x20a\n\x20histogram\
    \x20is\x20provided.\n\n\r\n\x05\x04\x0c\x02\x03\x05\x12\x04\xa8\x03\x02\
    \t\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xa8\x03\n\x0f\n\r\n\x05\x04\x0c\
    \x02\x03\x03\x12\x04\xa8\x03\x12\x13\n\xf5\x03\n\x04\x04\x0c\x02\x04\x12\
    \x04\xb2\x03\x02\x1a\x1a\xe6\x03\x20sum\x20of\x20the\x20values\x20in\x20\
    the\x20population.\x20If\x20count\x20is\x20zero\x20then\x20this\x20field\
    \n\x20must\x20be\x20zero.\n\n\x20Note:\x20Sum\x20should\x20only\x20be\
    \x20filled\x20out\x20when\x20measuring\x20non-negative\x20discrete\n\x20\
    events,\x20and\x20is\x20assumed\x20to\x20be\x20monotonic\x20over\x20the\
    \x20values\x20of\x20these\x20events.\n\x20Negative\x20events\x20*can*\
    \x20be\x20recorded,\x20but\x20sum\x20should\x20not\x20be\x20filled\x20ou\
    t\x20when\n\x20doing\x20so.\x20\x20This\x20is\x20specifically\x20to\x20e\
    nforce\x20compatibility\x20w/\x20OpenMetrics,\n\x20see:\x20https://githu\
    b.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.\
    md#histogram\n\n\r\n\x05\x04\x0c\x02\x04\x04\x12\x04\xb2\x03\x02\n\n\r\n\
    \x05\x04\x0c\x02\x04\x05\x12\x04\xb2\x03\x0b\x11\n\r\n\x05\x04\x0c\x02\
    \x04\x01\x12\x04\xb2\x03\x12\x15\n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\
    \xb2\x03\x18\x19\n\xb2\x02\n\x04\x04\x0c\x02\x05\x12\x04\xbb\x03\x02%\
    \x1a\xa3\x02\x20bucket_counts\x20is\x20an\x20optional\x20field\x20contai\
    ns\x20the\x20count\x20values\x20of\x20histogram\n\x20for\x20each\x20buck\
    et.\n\n\x20The\x20sum\x20of\x20the\x20bucket_counts\x20must\x20equal\x20\
    the\x20value\x20in\x20the\x20count\x20field.\n\n\x20The\x20number\x20of\
    \x20elements\x20in\x20bucket_counts\x20array\x20must\x20be\x20by\x20one\
    \x20greater\x20than\n\x20the\x20number\x20of\x20elements\x20in\x20explic\
    it_bounds\x20array.\n\n\r\n\x05\x04\x0c\x02\x05\x04\x12\x04\xbb\x03\x02\
    \n\n\r\n\x05\x04\x0c\x02\x05\x05\x12\x04\xbb\x03\x0b\x12\n\r\n\x05\x04\
    \x0c\x02\x05\x01\x12\x04\xbb\x03\x13\x20\n\r\n\x05\x04\x0c\x02\x05\x03\
    \x12\x04\xbb\x03#$\n\xd7\x04\n\x04\x04\x0c\x02\x06\x12\x04\xca\x03\x02&\
    \x1a\xc8\x04\x20explicit_bounds\x20specifies\x20buckets\x20with\x20expli\
    citly\x20defined\x20bounds\x20for\x20values.\n\n\x20The\x20boundaries\
    \x20for\x20bucket\x20at\x20index\x20i\x20are:\n\n\x20(-infinity,\x20expl\
    icit_bounds[i]]\x20for\x20i\x20==\x200\n\x20(explicit_bounds[i-1],\x20ex\
    plicit_bounds[i]]\x20for\x200\x20<\x20i\x20<\x20size(explicit_bounds)\n\
    \x20(explicit_bounds[i-1],\x20+infinity)\x20for\x20i\x20==\x20size(expli\
    cit_bounds)\n\n\x20The\x20values\x20in\x20the\x20explicit_bounds\x20arra\
    y\x20must\x20be\x20strictly\x20increasing.\n\n\x20Histogram\x20buckets\
    \x20are\x20inclusive\x20of\x20their\x20upper\x20boundary,\x20except\x20t\
    he\x20last\n\x20bucket\x20where\x20the\x20boundary\x20is\x20at\x20infini\
    ty.\x20This\x20format\x20is\x20intentionally\n\x20compatible\x20with\x20\
    the\x20OpenMetrics\x20histogram\x20definition.\n\n\r\n\x05\x04\x0c\x02\
    \x06\x04\x12\x04\xca\x03\x02\n\n\r\n\x05\x04\x0c\x02\x06\x05\x12\x04\xca\
    \x03\x0b\x11\n\r\n\x05\x04\x0c\x02\x06\x01\x12\x04\xca\x03\x12!\n\r\n\
    \x05\x04\x0c\x02\x06\x03\x12\x04\xca\x03$%\no\n\x04\x04\x0c\x02\x07\x12\
    \x04\xce\x03\x02\"\x1aa\x20(Optional)\x20List\x20of\x20exemplars\x20coll\
    ected\x20from\n\x20measurements\x20that\x20were\x20used\x20to\x20form\
    \x20the\x20data\x20point\n\n\r\n\x05\x04\x0c\x02\x07\x04\x12\x04\xce\x03\
    \x02\n\n\r\n\x05\x04\x0c\x02\x07\x06\x12\x04\xce\x03\x0b\x13\n\r\n\x05\
    \x04\x0c\x02\x07\x01\x12\x04\xce\x03\x14\x1d\n\r\n\x05\x04\x0c\x02\x07\
    \x03\x12\x04\xce\x03\x20!\n}\n\x04\x04\x0c\x02\x08\x12\x04\xd2\x03\x02\
    \x14\x1ao\x20Flags\x20that\x20apply\x20to\x20this\x20specific\x20data\
    \x20point.\x20\x20See\x20DataPointFlags\n\x20for\x20the\x20available\x20\
    flags\x20and\x20their\x20meaning.\n\n\r\n\x05\x04\x0c\x02\x08\x05\x12\
    \x04\xd2\x03\x02\x08\n\r\n\x05\x04\x0c\x02\x08\x01\x12\x04\xd2\x03\t\x0e\
    \n\r\n\x05\x04\x0c\x02\x08\x03\x12\x04\xd2\x03\x11\x13\nE\n\x04\x04\x0c\
    \x02\t\x12\x04\xd5\x03\x02\x1b\x1a7\x20min\x20is\x20the\x20minimum\x20va\
    lue\x20over\x20(start_time,\x20end_time].\n\n\r\n\x05\x04\x0c\x02\t\x04\
    \x12\x04\xd5\x03\x02\n\n\r\n\x05\x04\x0c\x02\t\x05\x12\x04\xd5\x03\x0b\
    \x11\n\r\n\x05\x04\x0c\x02\t\x01\x12\x04\xd5\x03\x12\x15\n\r\n\x05\x04\
    \x0c\x02\t\x03\x12\x04\xd5\x03\x18\x1a\nE\n\x04\x04\x0c\x02\n\x12\x04\
    \xd8\x03\x02\x1b\x1a7\x20max\x20is\x20the\x20maximum\x20value\x20over\
    \x20(start_time,\x20end_time].\n\n\r\n\x05\x04\x0c\x02\n\x04\x12\x04\xd8\
    \x03\x02\n\n\r\n\x05\x04\x0c\x02\n\x05\x12\x04\xd8\x03\x0b\x11\n\r\n\x05\
    \x04\x0c\x02\n\x01\x12\x04\xd8\x03\x12\x15\n\r\n\x05\x04\x0c\x02\n\x03\
    \x12\x04\xd8\x03\x18\x1a\n\xcf\x02\n\x02\x04\r\x12\x06\xe0\x03\0\xc5\x04\
    \x01\x1a\xc0\x02\x20ExponentialHistogramDataPoint\x20is\x20a\x20single\
    \x20data\x20point\x20in\x20a\x20timeseries\x20that\x20describes\x20the\n\
    \x20time-varying\x20values\x20of\x20a\x20ExponentialHistogram\x20of\x20d\
    ouble\x20values.\x20A\x20ExponentialHistogram\x20contains\n\x20summary\
    \x20statistics\x20for\x20a\x20population\x20of\x20values,\x20it\x20may\
    \x20optionally\x20contain\x20the\n\x20distribution\x20of\x20those\x20val\
    ues\x20across\x20a\x20set\x20of\x20buckets.\n\n\n\x0b\n\x03\x04\r\x01\
    \x12\x04\xe0\x03\x08%\n\x88\x02\n\x04\x04\r\x02\0\x12\x04\xe5\x03\x02#\
    \x1a\xf9\x01\x20The\x20set\x20of\x20key/value\x20pairs\x20that\x20unique\
    ly\x20identify\x20the\x20timeseries\x20from\n\x20where\x20this\x20point\
    \x20belongs.\x20The\x20list\x20may\x20be\x20empty\x20(may\x20contain\x20\
    0\x20elements).\n\x20Attribute\x20keys\x20MUST\x20be\x20unique\x20(it\
    \x20is\x20not\x20allowed\x20to\x20have\x20more\x20than\x20one\n\x20attri\
    bute\x20with\x20the\x20same\x20key).\n\n\r\n\x05\x04\r\x02\0\x04\x12\x04\
    \xe5\x03\x02\n\n\r\n\x05\x04\r\x02\0\x06\x12\x04\xe5\x03\x0b\x13\n\r\n\
    \x05\x04\r\x02\0\x01\x12\x04\xe5\x03\x14\x1e\n\r\n\x05\x04\r\x02\0\x03\
    \x12\x04\xe5\x03!\"\n\xc5\x01\n\x04\x04\r\x02\x01\x12\x04\xec\x03\x02#\
    \x1a\xb6\x01\x20StartTimeUnixNano\x20is\x20optional\x20but\x20strongly\
    \x20encouraged,\x20see\x20the\n\x20the\x20detailed\x20comments\x20above\
    \x20Metric.\n\n\x20Value\x20is\x20UNIX\x20Epoch\x20time\x20in\x20nanosec\
    onds\x20since\x2000:00:00\x20UTC\x20on\x201\x20January\n\x201970.\n\n\r\
    \n\x05\x04\r\x02\x01\x05\x12\x04\xec\x03\x02\t\n\r\n\x05\x04\r\x02\x01\
    \x01\x12\x04\xec\x03\n\x1e\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xec\x03!\
    \"\n\xa3\x01\n\x04\x04\r\x02\x02\x12\x04\xf2\x03\x02\x1d\x1a\x94\x01\x20\
    TimeUnixNano\x20is\x20required,\x20see\x20the\x20detailed\x20comments\
    \x20above\x20Metric.\n\n\x20Value\x20is\x20UNIX\x20Epoch\x20time\x20in\
    \x20nanoseconds\x20since\x2000:00:00\x20UTC\x20on\x201\x20January\n\x201\
    970.\n\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xf2\x03\x02\t\n\r\n\x05\x04\r\
    \x02\x02\x01\x12\x04\xf2\x03\n\x18\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\
    \xf2\x03\x1b\x1c\n\xdd\x01\n\x04\x04\r\x02\x03\x12\x04\xf7\x03\x02\x14\
    \x1a\xce\x01\x20count\x20is\x20the\x20number\x20of\x20values\x20in\x20th\
    e\x20population.\x20Must\x20be\n\x20non-negative.\x20This\x20value\x20mu\
    st\x20be\x20equal\x20to\x20the\x20sum\x20of\x20the\x20\"bucket_counts\"\
    \n\x20values\x20in\x20the\x20positive\x20and\x20negative\x20Buckets\x20p\
    lus\x20the\x20\"zero_count\"\x20field.\n\n\r\n\x05\x04\r\x02\x03\x05\x12\
    \x04\xf7\x03\x02\t\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\xf7\x03\n\x0f\n\r\
    \n\x05\x04\r\x02\x03\x03\x12\x04\xf7\x03\x12\x13\n\xf5\x03\n\x04\x04\r\
    \x02\x04\x12\x04\x81\x04\x02\x1a\x1a\xe6\x03\x20sum\x20of\x20the\x20valu\
    es\x20in\x20the\x20population.\x20If\x20count\x20is\x20zero\x20then\x20t\
    his\x20field\n\x20must\x20be\x20zero.\n\n\x20Note:\x20Sum\x20should\x20o\
    nly\x20be\x20filled\x20out\x20when\x20measuring\x20non-negative\x20discr\
    ete\n\x20events,\x20and\x20is\x20assumed\x20to\x20be\x20monotonic\x20ove\
    r\x20the\x20values\x20of\x20these\x20events.\n\x20Negative\x20events\x20\
    *can*\x20be\x20recorded,\x20but\x20sum\x20should\x20not\x20be\x20filled\
    \x20out\x20when\n\x20doing\x20so.\x20\x20This\x20is\x20specifically\x20t\
    o\x20enforce\x20compatibility\x20w/\x20OpenMetrics,\n\x20see:\x20https:/\
    /github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMe\
    trics.md#histogram\n\n\r\n\x05\x04\r\x02\x04\x04\x12\x04\x81\x04\x02\n\n\
    \r\n\x05\x04\r\x02\x04\x05\x12\x04\x81\x04\x0b\x11\n\r\n\x05\x04\r\x02\
    \x04\x01\x12\x04\x81\x04\x12\x15\n\r\n\x05\x04\r\x02\x04\x03\x12\x04\x81\
    \x04\x18\x19\n\xe2\x04\n\x04\x04\r\x02\x05\x12\x04\x92\x04\x02\x13\x1a\
    \xd3\x04\x20scale\x20describes\x20the\x20resolution\x20of\x20the\x20hist\
    ogram.\x20\x20Boundaries\x20are\n\x20located\x20at\x20powers\x20of\x20th\
    e\x20base,\x20where:\n\n\x20\x20\x20base\x20=\x20(2^(2^-scale))\n\n\x20T\
    he\x20histogram\x20bucket\x20identified\x20by\x20`index`,\x20a\x20signed\
    \x20integer,\n\x20contains\x20values\x20that\x20are\x20greater\x20than\
    \x20or\x20equal\x20to\x20(base^index)\x20and\n\x20less\x20than\x20(base^\
    (index+1)).\n\n\x20The\x20positive\x20and\x20negative\x20ranges\x20of\
    \x20the\x20histogram\x20are\x20expressed\n\x20separately.\x20\x20Negativ\
    e\x20values\x20are\x20mapped\x20by\x20their\x20absolute\x20value\n\x20in\
    to\x20the\x20negative\x20range\x20using\x20the\x20same\x20scale\x20as\
    \x20the\x20positive\x20range.\n\n\x20scale\x20is\x20not\x20restricted\
    \x20by\x20the\x20protocol,\x20as\x20the\x20permissible\n\x20values\x20de\
    pend\x20on\x20the\x20range\x20of\x20the\x20data.\n\n\r\n\x05\x04\r\x02\
    \x05\x05\x12\x04\x92\x04\x02\x08\n\r\n\x05\x04\r\x02\x05\x01\x12\x04\x92\
    \x04\t\x0e\n\r\n\x05\x04\r\x02\x05\x03\x12\x04\x92\x04\x11\x12\n\xaa\x03\
    \n\x04\x04\r\x02\x06\x12\x04\x9c\x04\x02\x19\x1a\x9b\x03\x20zero_count\
    \x20is\x20the\x20count\x20of\x20values\x20that\x20are\x20either\x20exact\
    ly\x20zero\x20or\n\x20within\x20the\x20region\x20considered\x20zero\x20b\
    y\x20the\x20instrumentation\x20at\x20the\n\x20tolerated\x20degree\x20of\
    \x20precision.\x20\x20This\x20bucket\x20stores\x20values\x20that\n\x20ca\
    nnot\x20be\x20expressed\x20using\x20the\x20standard\x20exponential\x20fo\
    rmula\x20as\n\x20well\x20as\x20values\x20that\x20have\x20been\x20rounded\
    \x20to\x20zero.\n\n\x20Implementations\x20MAY\x20consider\x20the\x20zero\
    \x20bucket\x20to\x20have\x20probability\n\x20mass\x20equal\x20to\x20(zer\
    o_count\x20/\x20count).\n\n\r\n\x05\x04\r\x02\x06\x05\x12\x04\x9c\x04\
    \x02\t\n\r\n\x05\x04\r\x02\x06\x01\x12\x04\x9c\x04\n\x14\n\r\n\x05\x04\r\
    \x02\x06\x03\x12\x04\x9c\x04\x17\x18\nQ\n\x04\x04\r\x02\x07\x12\x04\x9f\
    \x04\x02\x17\x1aC\x20positive\x20carries\x20the\x20positive\x20range\x20\
    of\x20exponential\x20bucket\x20counts.\n\n\r\n\x05\x04\r\x02\x07\x06\x12\
    \x04\x9f\x04\x02\t\n\r\n\x05\x04\r\x02\x07\x01\x12\x04\x9f\x04\n\x12\n\r\
    \n\x05\x04\r\x02\x07\x03\x12\x04\x9f\x04\x15\x16\nQ\n\x04\x04\r\x02\x08\
    \x12\x04\xa2\x04\x02\x17\x1aC\x20negative\x20carries\x20the\x20negative\
    \x20range\x20of\x20exponential\x20bucket\x20counts.\n\n\r\n\x05\x04\r\
    \x02\x08\x06\x12\x04\xa2\x04\x02\t\n\r\n\x05\x04\r\x02\x08\x01\x12\x04\
    \xa2\x04\n\x12\n\r\n\x05\x04\r\x02\x08\x03\x12\x04\xa2\x04\x15\x16\n_\n\
    \x04\x04\r\x03\0\x12\x06\xa6\x04\x02\xb6\x04\x03\x1aO\x20Buckets\x20are\
    \x20a\x20set\x20of\x20bucket\x20counts,\x20encoded\x20in\x20a\x20contigu\
    ous\x20array\n\x20of\x20counts.\n\n\r\n\x05\x04\r\x03\0\x01\x12\x04\xa6\
    \x04\n\x11\n\xa1\x01\n\x06\x04\r\x03\0\x02\0\x12\x04\xaa\x04\x04\x16\x1a\
    \x90\x01\x20Offset\x20is\x20the\x20bucket\x20index\x20of\x20the\x20first\
    \x20entry\x20in\x20the\x20bucket_counts\x20array.\n\n\x20Note:\x20This\
    \x20uses\x20a\x20varint\x20encoding\x20as\x20a\x20simple\x20form\x20of\
    \x20compression.\n\n\x0f\n\x07\x04\r\x03\0\x02\0\x05\x12\x04\xaa\x04\x04\
    \n\n\x0f\n\x07\x04\r\x03\0\x02\0\x01\x12\x04\xaa\x04\x0b\x11\n\x0f\n\x07\
    \x04\r\x03\0\x02\0\x03\x12\x04\xaa\x04\x14\x15\n\x9e\x03\n\x06\x04\r\x03\
    \0\x02\x01\x12\x04\xb5\x04\x04&\x1a\x8d\x03\x20Count\x20is\x20an\x20arra\
    y\x20of\x20counts,\x20where\x20count[i]\x20carries\x20the\x20count\n\x20\
    of\x20the\x20bucket\x20at\x20index\x20(offset+i).\x20\x20count[i]\x20is\
    \x20the\x20count\x20of\n\x20values\x20greater\x20than\x20or\x20equal\x20\
    to\x20base^(offset+i)\x20and\x20less\x20than\n\x20base^(offset+i+1).\n\n\
    \x20Note:\x20By\x20contrast,\x20the\x20explicit\x20HistogramDataPoint\
    \x20uses\n\x20fixed64.\x20\x20This\x20field\x20is\x20expected\x20to\x20h\
    ave\x20many\x20buckets,\n\x20especially\x20zeros,\x20so\x20uint64\x20has\
    \x20been\x20selected\x20to\x20ensure\n\x20varint\x20encoding.\n\n\x0f\n\
    \x07\x04\r\x03\0\x02\x01\x04\x12\x04\xb5\x04\x04\x0c\n\x0f\n\x07\x04\r\
    \x03\0\x02\x01\x05\x12\x04\xb5\x04\r\x13\n\x0f\n\x07\x04\r\x03\0\x02\x01\
    \x01\x12\x04\xb5\x04\x14!\n\x0f\n\x07\x04\r\x03\0\x02\x01\x03\x12\x04\
    \xb5\x04$%\n}\n\x04\x04\r\x02\t\x12\x04\xba\x04\x02\x14\x1ao\x20Flags\
    \x20that\x20apply\x20to\x20this\x20specific\x20data\x20point.\x20\x20See\
    \x20DataPointFlags\n\x20for\x20the\x20available\x20flags\x20and\x20their\
    \x20meaning.\n\n\r\n\x05\x04\r\x02\t\x05\x12\x04\xba\x04\x02\x08\n\r\n\
    \x05\x04\r\x02\t\x01\x12\x04\xba\x04\t\x0e\n\r\n\x05\x04\r\x02\t\x03\x12\
    \x04\xba\x04\x11\x13\no\n\x04\x04\r\x02\n\x12\x04\xbe\x04\x02#\x1aa\x20(\
    Optional)\x20List\x20of\x20exemplars\x20collected\x20from\n\x20measureme\
    nts\x20that\x20were\x20used\x20to\x20form\x20the\x20data\x20point\n\n\r\
    \n\x05\x04\r\x02\n\x04\x12\x04\xbe\x04\x02\n\n\r\n\x05\x04\r\x02\n\x06\
    \x12\x04\xbe\x04\x0b\x13\n\r\n\x05\x04\r\x02\n\x01\x12\x04\xbe\x04\x14\
    \x1d\n\r\n\x05\x04\r\x02\n\x03\x12\x04\xbe\x04\x20\"\nE\n\x04\x04\r\x02\
    \x0b\x12\x04\xc1\x04\x02\x1b\x1a7\x20min\x20is\x20the\x20minimum\x20valu\
    e\x20over\x20(start_time,\x20end_time].\n\n\r\n\x05\x04\r\x02\x0b\x04\
    \x12\x04\xc1\x04\x02\n\n\r\n\x05\x04\r\x02\x0b\x05\x12\x04\xc1\x04\x0b\
    \x11\n\r\n\x05\x04\r\x02\x0b\x01\x12\x04\xc1\x04\x12\x15\n\r\n\x05\x04\r\
    \x02\x0b\x03\x12\x04\xc1\x04\x18\x1a\nE\n\x04\x04\r\x02\x0c\x12\x04\xc4\
    \x04\x02\x1b\x1a7\x20max\x20is\x20the\x20maximum\x20value\x20over\x20(st\
    art_time,\x20end_time].\n\n\r\n\x05\x04\r\x02\x0c\x04\x12\x04\xc4\x04\
    \x02\n\n\r\n\x05\x04\r\x02\x0c\x05\x12\x04\xc4\x04\x0b\x11\n\r\n\x05\x04\
    \r\x02\x0c\x01\x12\x04\xc4\x04\x12\x15\n\r\n\x05\x04\r\x02\x0c\x03\x12\
    \x04\xc4\x04\x18\x1a\n\x84\x01\n\x02\x04\x0e\x12\x06\xc9\x04\0\x86\x05\
    \x01\x1av\x20SummaryDataPoint\x20is\x20a\x20single\x20data\x20point\x20i\
    n\x20a\x20timeseries\x20that\x20describes\x20the\n\x20time-varying\x20va\
    lues\x20of\x20a\x20Summary\x20metric.\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\
    \xc9\x04\x08\x18\n\x0b\n\x03\x04\x0e\t\x12\x04\xca\x04\x02\r\n\x0c\n\x04\
    \x04\x0e\t\0\x12\x04\xca\x04\x0b\x0c\n\r\n\x05\x04\x0e\t\0\x01\x12\x04\
    \xca\x04\x0b\x0c\n\r\n\x05\x04\x0e\t\0\x02\x12\x04\xca\x04\x0b\x0c\n\x88\
    \x02\n\x04\x04\x0e\x02\0\x12\x04\xd0\x04\x02#\x1a\xf9\x01\x20The\x20set\
    \x20of\x20key/value\x20pairs\x20that\x20uniquely\x20identify\x20the\x20t\
    imeseries\x20from\n\x20where\x20this\x20point\x20belongs.\x20The\x20list\
    \x20may\x20be\x20empty\x20(may\x20contain\x200\x20elements).\n\x20Attrib\
    ute\x20keys\x20MUST\x20be\x20unique\x20(it\x20is\x20not\x20allowed\x20to\
    \x20have\x20more\x20than\x20one\n\x20attribute\x20with\x20the\x20same\
    \x20key).\n\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xd0\x04\x02\n\n\r\n\x05\
    \x04\x0e\x02\0\x06\x12\x04\xd0\x04\x0b\x13\n\r\n\x05\x04\x0e\x02\0\x01\
    \x12\x04\xd0\x04\x14\x1e\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xd0\x04!\"\
    \n\xc5\x01\n\x04\x04\x0e\x02\x01\x12\x04\xd7\x04\x02#\x1a\xb6\x01\x20Sta\
    rtTimeUnixNano\x20is\x20optional\x20but\x20strongly\x20encouraged,\x20se\
    e\x20the\n\x20the\x20detailed\x20comments\x20above\x20Metric.\n\n\x20Val\
    ue\x20is\x20UNIX\x20Epoch\x20time\x20in\x20nanoseconds\x20since\x2000:00\
    :00\x20UTC\x20on\x201\x20January\n\x201970.\n\n\r\n\x05\x04\x0e\x02\x01\
    \x05\x12\x04\xd7\x04\x02\t\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xd7\x04\
    \n\x1e\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xd7\x04!\"\n\xa3\x01\n\x04\
    \x04\x0e\x02\x02\x12\x04\xdd\x04\x02\x1d\x1a\x94\x01\x20TimeUnixNano\x20\
    is\x20required,\x20see\x20the\x20detailed\x20comments\x20above\x20Metric\
    .\n\n\x20Value\x20is\x20UNIX\x20Epoch\x20time\x20in\x20nanoseconds\x20si\
    nce\x2000:00:00\x20UTC\x20on\x201\x20January\n\x201970.\n\n\r\n\x05\x04\
    \x0e\x02\x02\x05\x12\x04\xdd\x04\x02\t\n\r\n\x05\x04\x0e\x02\x02\x01\x12\
    \x04\xdd\x04\n\x18\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xdd\x04\x1b\x1c\
    \nV\n\x04\x04\x0e\x02\x03\x12\x04\xe0\x04\x02\x14\x1aH\x20count\x20is\
    \x20the\x20number\x20of\x20values\x20in\x20the\x20population.\x20Must\
    \x20be\x20non-negative.\n\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\xe0\x04\
    \x02\t\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xe0\x04\n\x0f\n\r\n\x05\x04\
    \x0e\x02\x03\x03\x12\x04\xe0\x04\x12\x13\n\xf3\x03\n\x04\x04\x0e\x02\x04\
    \x12\x04\xea\x04\x02\x11\x1a\xe4\x03\x20sum\x20of\x20the\x20values\x20in\
    \x20the\x20population.\x20If\x20count\x20is\x20zero\x20then\x20this\x20f\
    ield\n\x20must\x20be\x20zero.\n\n\x20Note:\x20Sum\x20should\x20only\x20b\
    e\x20filled\x20out\x20when\x20measuring\x20non-negative\x20discrete\n\
    \x20events,\x20and\x20is\x20assumed\x20to\x20be\x20monotonic\x20over\x20\
    the\x20values\x20of\x20these\x20events.\n\x20Negative\x20events\x20*can*\
    \x20be\x20recorded,\x20but\x20sum\x20should\x20not\x20be\x20filled\x20ou\
    t\x20when\n\x20doing\x20so.\x20\x20This\x20is\x20specifically\x20to\x20e\
    nforce\x20compatibility\x20w/\x20OpenMetrics,\n\x20see:\x20https://githu\
    b.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.\
    md#summary\n\n\r\n\x05\x04\x0e\x02\x04\x05\x12\x04\xea\x04\x02\x08\n\r\n\
    \x05\x04\x0e\x02\x04\x01\x12\x04\xea\x04\t\x0c\n\r\n\x05\x04\x0e\x02\x04\
    \x03\x12\x04\xea\x04\x0f\x10\n\xfd\x02\n\x04\x04\x0e\x03\0\x12\x06\xf4\
    \x04\x02\xfd\x04\x03\x1a\xec\x02\x20Represents\x20the\x20value\x20at\x20\
    a\x20given\x20quantile\x20of\x20a\x20distribution.\n\n\x20To\x20record\
    \x20Min\x20and\x20Max\x20values\x20following\x20conventions\x20are\x20us\
    ed:\n\x20-\x20The\x201.0\x20quantile\x20is\x20equivalent\x20to\x20the\
    \x20maximum\x20value\x20observed.\n\x20-\x20The\x200.0\x20quantile\x20is\
    \x20equivalent\x20to\x20the\x20minimum\x20value\x20observed.\n\n\x20See\
    \x20the\x20following\x20issue\x20for\x20more\x20context:\n\x20https://gi\
    thub.com/open-telemetry/opentelemetry-proto/issues/125\n\n\r\n\x05\x04\
    \x0e\x03\0\x01\x12\x04\xf4\x04\n\x19\nV\n\x06\x04\x0e\x03\0\x02\0\x12\
    \x04\xf7\x04\x04\x18\x1aF\x20The\x20quantile\x20of\x20a\x20distribution.\
    \x20Must\x20be\x20in\x20the\x20interval\n\x20[0.0,\x201.0].\n\n\x0f\n\
    \x07\x04\x0e\x03\0\x02\0\x05\x12\x04\xf7\x04\x04\n\n\x0f\n\x07\x04\x0e\
    \x03\0\x02\0\x01\x12\x04\xf7\x04\x0b\x13\n\x0f\n\x07\x04\x0e\x03\0\x02\0\
    \x03\x12\x04\xf7\x04\x16\x17\nl\n\x06\x04\x0e\x03\0\x02\x01\x12\x04\xfc\
    \x04\x04\x15\x1a\\\x20The\x20value\x20at\x20the\x20given\x20quantile\x20\
    of\x20a\x20distribution.\n\n\x20Quantile\x20values\x20must\x20NOT\x20be\
    \x20negative.\n\n\x0f\n\x07\x04\x0e\x03\0\x02\x01\x05\x12\x04\xfc\x04\
    \x04\n\n\x0f\n\x07\x04\x0e\x03\0\x02\x01\x01\x12\x04\xfc\x04\x0b\x10\n\
    \x0f\n\x07\x04\x0e\x03\0\x02\x01\x03\x12\x04\xfc\x04\x13\x14\n\xa7\x01\n\
    \x04\x04\x0e\x02\x05\x12\x04\x81\x05\x02/\x1a\x98\x01\x20(Optional)\x20l\
    ist\x20of\x20values\x20at\x20different\x20quantiles\x20of\x20the\x20dist\
    ribution\x20calculated\n\x20from\x20the\x20current\x20snapshot.\x20The\
    \x20quantiles\x20must\x20be\x20strictly\x20increasing.\n\n\r\n\x05\x04\
    \x0e\x02\x05\x04\x12\x04\x81\x05\x02\n\n\r\n\x05\x04\x0e\x02\x05\x06\x12\
    \x04\x81\x05\x0b\x1a\n\r\n\x05\x04\x0e\x02\x05\x01\x12\x04\x81\x05\x1b*\
    \n\r\n\x05\x04\x0e\x02\x05\x03\x12\x04\x81\x05-.\n}\n\x04\x04\x0e\x02\
    \x06\x12\x04\x85\x05\x02\x13\x1ao\x20Flags\x20that\x20apply\x20to\x20thi\
    s\x20specific\x20data\x20point.\x20\x20See\x20DataPointFlags\n\x20for\
    \x20the\x20available\x20flags\x20and\x20their\x20meaning.\n\n\r\n\x05\
    \x04\x0e\x02\x06\x05\x12\x04\x85\x05\x02\x08\n\r\n\x05\x04\x0e\x02\x06\
    \x01\x12\x04\x85\x05\t\x0e\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\x85\x05\
    \x11\x12\n\x87\x02\n\x02\x04\x0f\x12\x06\x8c\x05\0\xab\x05\x01\x1a\xf8\
    \x01\x20A\x20representation\x20of\x20an\x20exemplar,\x20which\x20is\x20a\
    \x20sample\x20input\x20measurement.\n\x20Exemplars\x20also\x20hold\x20in\
    formation\x20about\x20the\x20environment\x20when\x20the\x20measurement\n\
    \x20was\x20recorded,\x20for\x20example\x20the\x20span\x20and\x20trace\
    \x20ID\x20of\x20the\x20active\x20span\x20when\x20the\n\x20exemplar\x20wa\
    s\x20recorded.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\x8c\x05\x08\x10\n\x0b\n\
    \x03\x04\x0f\t\x12\x04\x8d\x05\x02\r\n\x0c\n\x04\x04\x0f\t\0\x12\x04\x8d\
    \x05\x0b\x0c\n\r\n\x05\x04\x0f\t\0\x01\x12\x04\x8d\x05\x0b\x0c\n\r\n\x05\
    \x04\x0f\t\0\x02\x12\x04\x8d\x05\x0b\x0c\n\xd9\x01\n\x04\x04\x0f\x02\0\
    \x12\x04\x92\x05\x02,\x1a\xca\x01\x20The\x20set\x20of\x20key/value\x20pa\
    irs\x20that\x20were\x20filtered\x20out\x20by\x20the\x20aggregator,\x20bu\
    t\n\x20recorded\x20alongside\x20the\x20original\x20measurement.\x20Only\
    \x20key/value\x20pairs\x20that\x20were\n\x20filtered\x20out\x20by\x20the\
    \x20aggregator\x20should\x20be\x20included\n\n\r\n\x05\x04\x0f\x02\0\x04\
    \x12\x04\x92\x05\x02\n\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\x92\x05\x0b\
    \x13\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x92\x05\x14'\n\r\n\x05\x04\x0f\
    \x02\0\x03\x12\x04\x92\x05*+\n\xa2\x01\n\x04\x04\x0f\x02\x01\x12\x04\x98\
    \x05\x02\x1d\x1a\x93\x01\x20time_unix_nano\x20is\x20the\x20exact\x20time\
    \x20when\x20this\x20exemplar\x20was\x20recorded\n\n\x20Value\x20is\x20UN\
    IX\x20Epoch\x20time\x20in\x20nanoseconds\x20since\x2000:00:00\x20UTC\x20\
    on\x201\x20January\n\x201970.\n\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\
    \x98\x05\x02\t\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\x98\x05\n\x18\n\r\n\
    \x05\x04\x0f\x02\x01\x03\x12\x04\x98\x05\x1b\x1c\n\xb0\x01\n\x04\x04\x0f\
    \x08\0\x12\x06\x9d\x05\x02\xa0\x05\x03\x1a\x9f\x01\x20The\x20value\x20of\
    \x20the\x20measurement\x20that\x20was\x20recorded.\x20An\x20exemplar\x20\
    is\n\x20considered\x20invalid\x20when\x20one\x20of\x20the\x20recognized\
    \x20value\x20fields\x20is\x20not\x20present\n\x20inside\x20this\x20oneof\
    .\n\n\r\n\x05\x04\x0f\x08\0\x01\x12\x04\x9d\x05\x08\r\n\x0c\n\x04\x04\
    \x0f\x02\x02\x12\x04\x9e\x05\x04\x19\n\r\n\x05\x04\x0f\x02\x02\x05\x12\
    \x04\x9e\x05\x04\n\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\x9e\x05\x0b\x14\
    \n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\x9e\x05\x17\x18\n\x0c\n\x04\x04\
    \x0f\x02\x03\x12\x04\x9f\x05\x04\x18\n\r\n\x05\x04\x0f\x02\x03\x05\x12\
    \x04\x9f\x05\x04\x0c\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\x9f\x05\r\x13\
    \n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\x9f\x05\x16\x17\n\xa5\x01\n\x04\
    \x04\x0f\x02\x04\x12\x04\xa5\x05\x02\x14\x1a\x96\x01\x20(Optional)\x20Sp\
    an\x20ID\x20of\x20the\x20exemplar\x20trace.\n\x20span_id\x20may\x20be\
    \x20missing\x20if\x20the\x20measurement\x20is\x20not\x20recorded\x20insi\
    de\x20a\x20trace\n\x20or\x20if\x20the\x20trace\x20is\x20not\x20sampled.\
    \n\n\r\n\x05\x04\x0f\x02\x04\x05\x12\x04\xa5\x05\x02\x07\n\r\n\x05\x04\
    \x0f\x02\x04\x01\x12\x04\xa5\x05\x08\x0f\n\r\n\x05\x04\x0f\x02\x04\x03\
    \x12\x04\xa5\x05\x12\x13\n\xa7\x01\n\x04\x04\x0f\x02\x05\x12\x04\xaa\x05\
    \x02\x15\x1a\x98\x01\x20(Optional)\x20Trace\x20ID\x20of\x20the\x20exempl\
    ar\x20trace.\n\x20trace_id\x20may\x20be\x20missing\x20if\x20the\x20measu\
    rement\x20is\x20not\x20recorded\x20inside\x20a\x20trace\n\x20or\x20if\
    \x20the\x20trace\x20is\x20not\x20sampled.\n\n\r\n\x05\x04\x0f\x02\x05\
    \x05\x12\x04\xaa\x05\x02\x07\n\r\n\x05\x04\x0f\x02\x05\x01\x12\x04\xaa\
    \x05\x08\x10\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\xaa\x05\x13\x14\n\xf0\
    \x01\n\x02\x04\x10\x12\x06\xb0\x05\0\xbc\x05\x01\x1a\xe1\x01\x20AnyValue\
    \x20is\x20used\x20to\x20represent\x20any\x20type\x20of\x20attribute\x20v\
    alue.\x20AnyValue\x20may\x20contain\x20a\n\x20primitive\x20value\x20such\
    \x20as\x20a\x20string\x20or\x20integer\x20or\x20it\x20may\x20contain\x20\
    an\x20arbitrary\x20nested\n\x20object\x20containing\x20arrays,\x20key-va\
    lue\x20lists\x20and\x20primitives.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xb0\
    \x05\x08\x10\n\xa0\x01\n\x04\x04\x10\x08\0\x12\x06\xb3\x05\x02\xbb\x05\
    \x03\x1a\x8f\x01\x20The\x20value\x20is\x20one\x20of\x20the\x20listed\x20\
    fields.\x20It\x20is\x20valid\x20for\x20all\x20values\x20to\x20be\x20unsp\
    ecified\n\x20in\x20which\x20case\x20this\x20AnyValue\x20is\x20considered\
    \x20to\x20be\x20\"empty\".\n\n\r\n\x05\x04\x10\x08\0\x01\x12\x04\xb3\x05\
    \x08\r\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xb4\x05\x04\x1c\n\r\n\x05\x04\
    \x10\x02\0\x05\x12\x04\xb4\x05\x04\n\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\
    \xb4\x05\x0b\x17\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xb4\x05\x1a\x1b\n\
    \x0c\n\x04\x04\x10\x02\x01\x12\x04\xb5\x05\x04\x18\n\r\n\x05\x04\x10\x02\
    \x01\x05\x12\x04\xb5\x05\x04\x08\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\
    \xb5\x05\t\x13\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xb5\x05\x16\x17\n\
    \x0c\n\x04\x04\x10\x02\x02\x12\x04\xb6\x05\x04\x18\n\r\n\x05\x04\x10\x02\
    \x02\x05\x12\x04\xb6\x05\x04\t\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xb6\
    \x05\n\x13\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xb6\x05\x16\x17\n\x0c\n\
    \x04\x04\x10\x02\x03\x12\x04\xb7\x05\x04\x1c\n\r\n\x05\x04\x10\x02\x03\
    \x05\x12\x04\xb7\x05\x04\n\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xb7\x05\
    \x0b\x17\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\xb7\x05\x1a\x1b\n\x0c\n\
    \x04\x04\x10\x02\x04\x12\x04\xb8\x05\x04\x1f\n\r\n\x05\x04\x10\x02\x04\
    \x06\x12\x04\xb8\x05\x04\x0e\n\r\n\x05\x04\x10\x02\x04\x01\x12\x04\xb8\
    \x05\x0f\x1a\n\r\n\x05\x04\x10\x02\x04\x03\x12\x04\xb8\x05\x1d\x1e\n\x0c\
    \n\x04\x04\x10\x02\x05\x12\x04\xb9\x05\x04\"\n\r\n\x05\x04\x10\x02\x05\
    \x06\x12\x04\xb9\x05\x04\x10\n\r\n\x05\x04\x10\x02\x05\x01\x12\x04\xb9\
    \x05\x11\x1d\n\r\n\x05\x04\x10\x02\x05\x03\x12\x04\xb9\x05\x20!\n\x0c\n\
    \x04\x04\x10\x02\x06\x12\x04\xba\x05\x04\x1a\n\r\n\x05\x04\x10\x02\x06\
    \x05\x12\x04\xba\x05\x04\t\n\r\n\x05\x04\x10\x02\x06\x01\x12\x04\xba\x05\
    \n\x15\n\r\n\x05\x04\x10\x02\x06\x03\x12\x04\xba\x05\x18\x19\n\x94\x01\n\
    \x02\x04\x11\x12\x06\xc0\x05\0\xc3\x05\x01\x1a\x85\x01\x20ArrayValue\x20\
    is\x20a\x20list\x20of\x20AnyValue\x20messages.\x20We\x20need\x20ArrayVal\
    ue\x20as\x20a\x20message\n\x20since\x20oneof\x20in\x20AnyValue\x20does\
    \x20not\x20allow\x20repeated\x20fields.\n\n\x0b\n\x03\x04\x11\x01\x12\
    \x04\xc0\x05\x08\x12\nM\n\x04\x04\x11\x02\0\x12\x04\xc2\x05\x02\x1f\x1a?\
    \x20Array\x20of\x20values.\x20The\x20array\x20may\x20be\x20empty\x20(con\
    tain\x200\x20elements).\n\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\xc2\x05\
    \x02\n\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xc2\x05\x0b\x13\n\r\n\x05\x04\
    \x11\x02\0\x01\x12\x04\xc2\x05\x14\x1a\n\r\n\x05\x04\x11\x02\0\x03\x12\
    \x04\xc2\x05\x1d\x1e\n\xfd\x02\n\x02\x04\x12\x12\x06\xca\x05\0\xd0\x05\
    \x01\x1a\xee\x02\x20KeyValueList\x20is\x20a\x20list\x20of\x20KeyValue\
    \x20messages.\x20We\x20need\x20KeyValueList\x20as\x20a\x20message\n\x20s\
    ince\x20`oneof`\x20in\x20AnyValue\x20does\x20not\x20allow\x20repeated\
    \x20fields.\x20Everywhere\x20else\x20where\x20we\x20need\n\x20a\x20list\
    \x20of\x20KeyValue\x20messages\x20(e.g.\x20in\x20Span)\x20we\x20use\x20`\
    repeated\x20KeyValue`\x20directly\x20to\n\x20avoid\x20unnecessary\x20ext\
    ra\x20wrapping\x20(which\x20slows\x20down\x20the\x20protocol).\x20The\
    \x202\x20approaches\n\x20are\x20semantically\x20equivalent.\n\n\x0b\n\
    \x03\x04\x12\x01\x12\x04\xca\x05\x08\x14\n\xd2\x01\n\x04\x04\x12\x02\0\
    \x12\x04\xcf\x05\x02\x1f\x1a\xc3\x01\x20A\x20collection\x20of\x20key/val\
    ue\x20pairs\x20of\x20key-value\x20pairs.\x20The\x20list\x20may\x20be\x20\
    empty\x20(may\n\x20contain\x200\x20elements).\n\x20The\x20keys\x20MUST\
    \x20be\x20unique\x20(it\x20is\x20not\x20allowed\x20to\x20have\x20more\
    \x20than\x20one\n\x20value\x20with\x20the\x20same\x20key).\n\n\r\n\x05\
    \x04\x12\x02\0\x04\x12\x04\xcf\x05\x02\n\n\r\n\x05\x04\x12\x02\0\x06\x12\
    \x04\xcf\x05\x0b\x13\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xcf\x05\x14\x1a\
    \n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xcf\x05\x1d\x1e\nj\n\x02\x04\x13\
    \x12\x06\xd4\x05\0\xd7\x05\x01\x1a\\\x20KeyValue\x20is\x20a\x20key-value\
    \x20pair\x20that\x20is\x20used\x20to\x20store\x20Span\x20attributes,\x20\
    Link\n\x20attributes,\x20etc.\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xd4\x05\
    \x08\x10\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xd5\x05\x02\x11\n\r\n\x05\x04\
    \x13\x02\0\x05\x12\x04\xd5\x05\x02\x08\n\r\n\x05\x04\x13\x02\0\x01\x12\
    \x04\xd5\x05\t\x0c\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xd5\x05\x0f\x10\n\
    \x0c\n\x04\x04\x13\x02\x01\x12\x04\xd6\x05\x02\x15\n\r\n\x05\x04\x13\x02\
    \x01\x06\x12\x04\xd6\x05\x02\n\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xd6\
    \x05\x0b\x10\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xd6\x05\x13\x14\n\x94\
    \x01\n\x02\x04\x14\x12\x06\xdb\x05\0\xe1\x05\x01\x1a\x85\x01\x20Instrume\
    ntationScope\x20is\x20a\x20message\x20representing\x20the\x20instrumenta\
    tion\x20scope\x20information\n\x20such\x20as\x20the\x20fully\x20qualifie\
    d\x20name\x20and\x20version.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\xdb\x05\
    \x08\x1c\nN\n\x04\x04\x14\x02\0\x12\x04\xdd\x05\x02\x12\x1a@\x20An\x20em\
    pty\x20instrumentation\x20scope\x20name\x20means\x20the\x20name\x20is\
    \x20unknown.\n\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xdd\x05\x02\x08\n\r\n\
    \x05\x04\x14\x02\0\x01\x12\x04\xdd\x05\t\r\n\r\n\x05\x04\x14\x02\0\x03\
    \x12\x04\xdd\x05\x10\x11\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xde\x05\x02\
    \x15\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xde\x05\x02\x08\n\r\n\x05\x04\
    \x14\x02\x01\x01\x12\x04\xde\x05\t\x10\n\r\n\x05\x04\x14\x02\x01\x03\x12\
    \x04\xde\x05\x13\x14\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\xdf\x05\x02#\n\
    \r\n\x05\x04\x14\x02\x02\x04\x12\x04\xdf\x05\x02\n\n\r\n\x05\x04\x14\x02\
    \x02\x06\x12\x04\xdf\x05\x0b\x13\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\
    \xdf\x05\x14\x1e\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xdf\x05!\"\n\x0c\
    \n\x04\x04\x14\x02\x03\x12\x04\xe0\x05\x02&\n\r\n\x05\x04\x14\x02\x03\
    \x05\x12\x04\xe0\x05\x02\x08\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\xe0\
    \x05\t!\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xe0\x05$%\n%\n\x02\x04\x15\
    \x12\x06\xe5\x05\0\xee\x05\x01\x1a\x17\x20Resource\x20information.\n\n\
    \x0b\n\x03\x04\x15\x01\x12\x04\xe5\x05\x08\x10\n\xa5\x01\n\x04\x04\x15\
    \x02\0\x12\x04\xe9\x05\x02#\x1a\x96\x01\x20Set\x20of\x20attributes\x20th\
    at\x20describe\x20the\x20resource.\n\x20Attribute\x20keys\x20MUST\x20be\
    \x20unique\x20(it\x20is\x20not\x20allowed\x20to\x20have\x20more\x20than\
    \x20one\n\x20attribute\x20with\x20the\x20same\x20key).\n\n\r\n\x05\x04\
    \x15\x02\0\x04\x12\x04\xe9\x05\x02\n\n\r\n\x05\x04\x15\x02\0\x06\x12\x04\
    \xe9\x05\x0b\x13\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xe9\x05\x14\x1e\n\r\
    \n\x05\x04\x15\x02\0\x03\x12\x04\xe9\x05!\"\n\x82\x01\n\x04\x04\x15\x02\
    \x01\x12\x04\xed\x05\x02&\x1at\x20dropped_attributes_count\x20is\x20the\
    \x20number\x20of\x20dropped\x20attributes.\x20If\x20the\x20value\x20is\
    \x200,\x20then\n\x20no\x20attributes\x20were\x20dropped.\n\n\r\n\x05\x04\
    \x15\x02\x01\x05\x12\x04\xed\x05\x02\x08\n\r\n\x05\x04\x15\x02\x01\x01\
    \x12\x04\xed\x05\t!\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xed\x05$%b\x06\
    proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(24);
            messages.push(ExportMetricsServiceRequest::generated_message_descriptor_data());
            messages.push(ExportMetricsServiceResponse::generated_message_descriptor_data());
            messages.push(MetricsData::generated_message_descriptor_data());
            messages.push(ResourceMetrics::generated_message_descriptor_data());
            messages.push(ScopeMetrics::generated_message_descriptor_data());
            messages.push(Metric::generated_message_descriptor_data());
            messages.push(Gauge::generated_message_descriptor_data());
            messages.push(Sum::generated_message_descriptor_data());
            messages.push(Histogram::generated_message_descriptor_data());
            messages.push(ExponentialHistogram::generated_message_descriptor_data());
            messages.push(Summary::generated_message_descriptor_data());
            messages.push(NumberDataPoint::generated_message_descriptor_data());
            messages.push(HistogramDataPoint::generated_message_descriptor_data());
            messages.push(ExponentialHistogramDataPoint::generated_message_descriptor_data());
            messages.push(SummaryDataPoint::generated_message_descriptor_data());
            messages.push(Exemplar::generated_message_descriptor_data());
            messages.push(AnyValue::generated_message_descriptor_data());
            messages.push(ArrayValue::generated_message_descriptor_data());
            messages.push(KeyValueList::generated_message_descriptor_data());
            messages.push(KeyValue::generated_message_descriptor_data());
            messages.push(InstrumentationScope::generated_message_descriptor_data());
            messages.push(Resource::generated_message_descriptor_data());
            messages.push(exponential_histogram_data_point::Buckets::generated_message_descriptor_data());
            messages.push(summary_data_point::ValueAtQuantile::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(AggregationTemporality::generated_enum_descriptor_data());
            enums.push(DataPointFlags::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
